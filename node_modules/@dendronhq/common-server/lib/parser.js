"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SchemaParserV2 = exports.ParserBaseV2 = void 0;
const common_all_1 = require("@dendronhq/common-all");
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const filesv2_1 = require("./filesv2");
const logger_1 = require("./logger");
let _LOGGER;
function getLogger() {
    if (!_LOGGER) {
        _LOGGER = logger_1.createLogger();
    }
    return _LOGGER;
}
class ParserBaseV2 {
    constructor(opts) {
        this.opts = opts;
    }
    get logger() {
        return this.opts.logger;
    }
}
exports.ParserBaseV2 = ParserBaseV2;
class SchemaParserV2 extends ParserBaseV2 {
    static async parseRaw(schemaOpts, opts) {
        const version = lodash_1.default.isArray(schemaOpts) ? 0 : 1;
        if (version > 0) {
            return await SchemaParserV2.parseSchemaModuleOpts(schemaOpts, opts);
        }
        else {
            // TODO: legacy
            const schemaDict = {};
            schemaOpts.map((ent) => {
                const schema = common_all_1.SchemaUtils.create(ent);
                schemaDict[schema.id] = schema;
            });
            const maybeRoot = lodash_1.default.find(lodash_1.default.values(schemaDict), {
                parent: "root",
            });
            return {
                version: 0,
                root: maybeRoot,
                schemas: schemaDict,
                fname: opts.fname,
                vault: opts.root,
            };
        }
    }
    static async parseSchemaModuleOpts(schemaModuleProps, opts) {
        const { imports, schemas, version } = schemaModuleProps;
        const { fname, root, wsRoot } = opts;
        getLogger().info({ ctx: "parseSchemaModuleOpts", fname, root, imports });
        const vpath = filesv2_1.vault2Path({ vault: root, wsRoot });
        let schemaModulesFromImport = [];
        await Promise.all(lodash_1.default.map(imports, async (ent) => {
            const fpath = path_1.default.join(vpath, ent + ".schema.yml");
            schemaModulesFromImport.push(await filesv2_1.file2Schema(fpath, wsRoot));
        }));
        const schemaPropsFromImport = schemaModulesFromImport.flatMap((mod) => {
            const domain = mod.fname;
            return lodash_1.default.values(mod.schemas).map((ent) => {
                ent.data.pattern = ent.data.pattern || ent.id;
                ent.id = `${domain}.${ent.id}`;
                ent.fname = fname;
                ent.parent = null;
                ent.children = ent.children.map((ent) => `${domain}.${ent}`);
                ent.vault = root;
                return ent;
            });
        });
        getLogger().debug({ ctx: "parseSchemaModuleOpts", schemaPropsFromImport });
        const schemaPropsFromFile = schemas.map((ent) => {
            return common_all_1.SchemaUtils.create({ ...ent, vault: root });
        });
        getLogger().debug({ ctx: "parseSchemaModuleOpts", schemaPropsFromFile });
        const schemasAll = schemaPropsFromImport.concat(schemaPropsFromFile);
        const schemasDict = {};
        schemasAll.forEach((ent) => {
            schemasDict[ent.id] = ent;
        });
        const rootModule = common_all_1.SchemaUtils.getModuleRoot(schemaModuleProps);
        const addConnections = (parent) => {
            lodash_1.default.map(parent.children, (ch) => {
                const child = schemasDict[ch];
                if (!child) {
                    throw new common_all_1.DendronError({
                        status: common_all_1.ERROR_STATUS.MISSING_SCHEMA,
                        message: JSON.stringify({ parent, missingChild: ch }),
                    });
                }
                common_all_1.DNodeUtils.addChild(parent, child);
                return addConnections(child);
            });
        };
        // add parent relationship
        addConnections(rootModule);
        return {
            version,
            imports,
            root: rootModule,
            schemas: schemasDict,
            fname,
            vault: root,
        };
    }
}
exports.SchemaParserV2 = SchemaParserV2;
//# sourceMappingURL=parser.js.map