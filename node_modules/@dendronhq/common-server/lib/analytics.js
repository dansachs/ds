"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SegmentClient = exports.TelemetryStatus = exports.SEGMENT_EVENTS = void 0;
const common_all_1 = require("@dendronhq/common-all");
const analytics_node_1 = __importDefault(require("analytics-node"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const lodash_1 = __importDefault(require("lodash"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const logger_1 = require("./logger");
var SiteEvents;
(function (SiteEvents) {
    SiteEvents["PUBLISH_CLICKED"] = "sitePublishClick";
    SiteEvents["SOURCE_INFO_ENTER"] = "sitePublishInfoEnter";
    SiteEvents["CREATED"] = "siteCreate";
    SiteEvents["UPDATE_START"] = "siteUpdateStart";
    SiteEvents["UPDATE_STOP"] = "siteUpdateStop";
    SiteEvents["VISIT_SITE"] = "siteVisit";
})(SiteEvents || (SiteEvents = {}));
var SubscriptionEvents;
(function (SubscriptionEvents) {
    SubscriptionEvents["CREATED"] = "subscriptionCreated";
})(SubscriptionEvents || (SubscriptionEvents = {}));
// === Types
var CompletionStatus;
(function (CompletionStatus) {
    CompletionStatus["OK"] = "ok";
})(CompletionStatus || (CompletionStatus = {}));
var UserTier;
(function (UserTier) {
    UserTier["SEED"] = "seed";
})(UserTier || (UserTier = {}));
exports.SEGMENT_EVENTS = {
    SiteEvents,
    SubscriptionEvents,
};
var TelemetryStatus;
(function (TelemetryStatus) {
    /** The user set that telemetry should be disabled in the workspace config. */
    TelemetryStatus["DISABLED_BY_WS_CONFIG"] = "disabled by ws config";
    /** The user set that telemetry should be disabled in VSCode settings. */
    TelemetryStatus["DISABLED_BY_VSCODE_CONFIG"] = "disabled by vscode config";
    /** The user used the Disable Telemetry command to disable telemetry. */
    TelemetryStatus["DISABLED_BY_COMMAND"] = "disabled by command";
    /** The user disabled telemetry in configuration, but used the Enable Telemetry command to give permission. */
    TelemetryStatus["ENABLED_BY_COMMAND"] = "enabled by command";
    /** The user allowed telemetry by configuration. */
    TelemetryStatus["ENABLED_BY_CONFIG"] = "enabled by config";
    /** The user did not opt out of telemetry prior to 0.46.0 update */
    TelemetryStatus["ENABLED_BY_MIGRATION"] = "enabled by migration";
})(TelemetryStatus = exports.TelemetryStatus || (exports.TelemetryStatus = {}));
class SegmentClient {
    constructor(_opts) {
        const key = common_all_1.env("SEGMENT_VSCODE_KEY");
        this.logger = logger_1.createLogger("SegmentClient");
        this._segmentInstance = new analytics_node_1.default(key);
        const status = SegmentClient.getStatus();
        this.logger.info({ msg: `user telemetry setting: ${status}` });
        this._hasOptedOut = SegmentClient.isDisabled();
        if (this.hasOptedOut) {
            this._anonymousId = "";
            return;
        }
        const uuidPath = path_1.default.join(os_1.default.homedir(), common_all_1.CONSTANTS.DENDRON_ID);
        this.logger.info({ msg: "telemetry initializing" });
        if (fs_extra_1.default.existsSync(uuidPath)) {
            this.logger.info({ msg: "using existing id" });
            this._anonymousId = lodash_1.default.trim(fs_extra_1.default.readFileSync(uuidPath, { encoding: "utf8" }));
        }
        else {
            this.logger.info({ msg: "creating new id" });
            this._anonymousId = common_all_1.genUUID();
            fs_extra_1.default.writeFileSync(uuidPath, this._anonymousId);
        }
    }
    static instance(opts) {
        if (lodash_1.default.isUndefined(this._singleton) || (opts === null || opts === void 0 ? void 0 : opts.forceNew)) {
            this._singleton = new SegmentClient(opts);
        }
        return this._singleton;
    }
    /** Legacy: If exists, Dendron telemetry has been disabled. */
    static getDisableConfigPath() {
        return path_1.default.join(os_1.default.homedir(), common_all_1.CONSTANTS.DENDRON_NO_TELEMETRY);
    }
    /** May contain configuration for Dendron telemetry. */
    static getConfigPath() {
        return path_1.default.join(os_1.default.homedir(), common_all_1.CONSTANTS.DENDRON_TELEMETRY);
    }
    static readConfig() {
        try {
            return fs_extra_1.default.readJSONSync(this.getConfigPath());
        }
        catch {
            return undefined;
        }
    }
    static getStatus() {
        // Legacy, this file would have been created if the user used the Dendron Disable command
        if (fs_extra_1.default.existsSync(this.getDisableConfigPath()))
            return TelemetryStatus.DISABLED_BY_COMMAND;
        const config = this.readConfig();
        // This is actually ambiguous, could have been using the command or by default.
        if (lodash_1.default.isUndefined(config))
            return TelemetryStatus.ENABLED_BY_CONFIG;
        return config.status;
    }
    static isDisabled(status) {
        if (lodash_1.default.isUndefined(status))
            status = this.getStatus();
        switch (status) {
            case TelemetryStatus.DISABLED_BY_COMMAND:
            case TelemetryStatus.DISABLED_BY_VSCODE_CONFIG:
            case TelemetryStatus.DISABLED_BY_WS_CONFIG:
                return true;
            default:
                return false;
        }
    }
    static isEnabled(status) {
        return !this.isDisabled(status);
    }
    static setByConfig(status) {
        if (lodash_1.default.isUndefined(status))
            status = this.getStatus();
        switch (status) {
            case TelemetryStatus.DISABLED_BY_COMMAND:
            case TelemetryStatus.ENABLED_BY_COMMAND:
            case TelemetryStatus.ENABLED_BY_MIGRATION:
                return false;
            default:
                return true;
        }
    }
    static enable(why) {
        // try to remove the legacy disable, if it exists
        try {
            fs_extra_1.default.removeSync(this.getDisableConfigPath());
        }
        catch {
            // expected, legacy disable config is missing.
        }
        fs_extra_1.default.writeJSONSync(this.getConfigPath(), { status: why });
    }
    static disable(why) {
        fs_extra_1.default.writeJSONSync(this.getConfigPath(), { status: why });
    }
    identifyAnonymous(props, opts) {
        this.identify(undefined, props, opts);
    }
    identify(id, props, opts) {
        if (this._hasOptedOut || this._segmentInstance == null) {
            return;
        }
        try {
            const { context } = opts || {};
            const identifyOpts = {
                anonymousId: this._anonymousId,
                traits: props,
                context,
            };
            if (id) {
                identifyOpts.userId = id;
            }
            this._segmentInstance.identify(identifyOpts);
            this._segmentInstance.flush();
        }
        catch (ex) {
            this.logger.error(ex);
        }
    }
    track(event, data, opts) {
        if (this._hasOptedOut || this._segmentInstance == null) {
            return;
        }
        const payload = { ...data };
        const { context } = opts || {};
        try {
            this._segmentInstance.track({
                anonymousId: this._anonymousId,
                event,
                properties: payload,
                context,
            });
        }
        catch (ex) {
            this.logger.error(ex);
        }
    }
    get hasOptedOut() {
        return this._hasOptedOut;
    }
}
exports.SegmentClient = SegmentClient;
//# sourceMappingURL=analytics.js.map