"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SeedService = exports.SeedInitMode = void 0;
const common_all_1 = require("@dendronhq/common-all");
const common_server_1 = require("@dendronhq/common-server");
const fs_extra_1 = __importDefault(require("fs-extra"));
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const workspace_1 = require("../workspace");
const registry_1 = require("./registry");
const utils_1 = require("./utils");
var SeedInitMode;
(function (SeedInitMode) {
    SeedInitMode["CREATE_WORKSPACE"] = "create_workspace";
    SeedInitMode["CONVERT_WORKSPACE"] = "convert_workspace";
})(SeedInitMode = exports.SeedInitMode || (exports.SeedInitMode = {}));
class SeedService {
    /**
     *
     * @param wsRoot - root of file
     * @param registryFile - custom yml file to look for registry
     */
    constructor({ wsRoot, registryFile, registry, }) {
        this.wsRoot = wsRoot;
        this.registryFile = registryFile;
        this.registry = registry || registry_1.SeedRegistry.create({ registryFile });
    }
    async getSeedOrErrorFromId(id) {
        const maybeSeed = await this.registry.info({ id });
        if (!maybeSeed) {
            return common_all_1.DendronError.createFromStatus({
                status: common_all_1.ERROR_STATUS.DOES_NOT_EXIST,
                message: `seed ${id} does not exist`,
            });
        }
        return maybeSeed;
    }
    async addSeed({ id, metaOnly }) {
        const seedOrError = await this.getSeedOrErrorFromId(id);
        if (seedOrError instanceof common_all_1.DendronError) {
            return {
                error: seedOrError,
            };
        }
        this.addSeedMetadata({ seed: seedOrError, wsRoot: this.wsRoot });
        let seedPath;
        if (!metaOnly) {
            seedPath = await this.cloneSeed({ seed: seedOrError });
        }
        return { data: { seedPath, seed: seedOrError } };
    }
    /**
     * Add seed metadata.
     * @returns
     */
    async addSeedMetadata({ seed, wsRoot, }) {
        const ws = new workspace_1.WorkspaceService({ wsRoot });
        const config = ws.config;
        const id = utils_1.SeedUtils.getSeedId({ ...seed });
        if (!config.seeds) {
            config.seeds = {};
        }
        const seedEntry = {};
        if (seed.site) {
            seedEntry.site = seed.site;
        }
        config.seeds[id] = seedEntry;
        await ws.addVault({
            vault: utils_1.SeedUtils.seed2Vault({ seed }),
            updateWorkspace: true,
            config,
            updateConfig: true,
        });
        return { seed };
    }
    /**
     *
     * @param branch - optional branch to clone from
     * @returns
     */
    async cloneSeed({ seed, branch }) {
        const wsRoot = this.wsRoot;
        const id = utils_1.SeedUtils.getSeedId(seed);
        const spath = utils_1.SeedUtils.seed2Path({ wsRoot, id });
        fs_extra_1.default.ensureDirSync(path_1.default.dirname(spath));
        const git = common_server_1.simpleGit({ baseDir: wsRoot });
        await git.clone(seed.repository.url, spath);
        if (branch) {
            await git.checkout(`origin/${branch}`, { "--track": "" });
        }
        return spath;
    }
    async init(opts) {
        const { wsRoot, seed, mode } = opts;
        const cpath = path_1.default.join(wsRoot, common_all_1.CONSTANTS.DENDRON_SEED_CONFIG);
        switch (mode) {
            case SeedInitMode.CREATE_WORKSPACE: {
                // write seed config
                common_server_1.writeYAML(cpath, seed);
                const ws = await workspace_1.WorkspaceService.createWorkspace({
                    wsRoot,
                    vaults: [],
                    createCodeWorkspace: true,
                });
                let config = ws.config;
                await ws.createVault({
                    vault: { fsPath: "vault" },
                    updateWorkspace: true,
                    config,
                    updateConfig: false,
                });
                await ws.setConfig(config);
                break;
            }
            case SeedInitMode.CONVERT_WORKSPACE: {
                const { error } = utils_1.SeedUtils.validateWorkspaceSeedConversion({ wsRoot });
                if (error) {
                    return {
                        error,
                    };
                }
                const ws = new workspace_1.WorkspaceService({ wsRoot });
                const vaultPath = common_all_1.VaultUtils.getRelPath(ws.config.vaults[0]);
                seed.root = vaultPath;
                common_server_1.writeYAML(cpath, seed);
                // validate
                break;
            }
            default:
                common_all_1.assertUnreachable();
        }
        return {
            data: {
                seed,
            },
        };
    }
    async info({ id }) {
        const resp = this.registry.info({ id });
        return resp;
    }
    async removeSeed({ id }) {
        const ws = new workspace_1.WorkspaceService({ wsRoot: this.wsRoot });
        const config = ws.config;
        if (!lodash_1.default.has(config.seeds, id)) {
            return {
                error: new common_all_1.DendronError({
                    status: common_all_1.ERROR_STATUS.DOES_NOT_EXIST,
                    message: `seed with id ${id} not in dendron.yml`,
                }),
            };
        }
        const seedOrError = await this.getSeedOrErrorFromId(id);
        if (seedOrError instanceof common_all_1.DendronError) {
            return {
                error: seedOrError,
            };
        }
        await this.removeSeedMetadata({ seed: seedOrError });
        const spath = utils_1.SeedUtils.seed2Path({ wsRoot: this.wsRoot, id });
        if (fs_extra_1.default.pathExistsSync(spath)) {
            fs_extra_1.default.removeSync(spath);
        }
        return { data: {} };
    }
    async removeSeedMetadata({ seed }) {
        const ws = new workspace_1.WorkspaceService({ wsRoot: this.wsRoot });
        await ws.removeVault({
            vault: utils_1.SeedUtils.seed2Vault({ seed }),
            updateWorkspace: true,
        });
        // remove seed entry
        const config = ws.config;
        delete (config.seeds || {})[utils_1.SeedUtils.getSeedId(seed)];
        ws.setConfig(config);
    }
}
exports.SeedService = SeedService;
//# sourceMappingURL=service.js.map