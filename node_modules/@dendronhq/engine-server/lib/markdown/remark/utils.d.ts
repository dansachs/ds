import { DNoteAnchor } from "@dendronhq/common-all";
import { DendronError, DEngineClient, DLink, DNoteAnchorPositioned, DNoteLink, DNoteLoc, DNoteRefLink, DNoteRefLinkRaw, getSlugger, NoteChangeEntry, NoteProps, Position } from "@dendronhq/common-all";
import * as mdastBuilder from "mdast-builder";
import { Processor } from "unified";
import { Node } from "unist";
import { VFile } from "vfile";
import { Anchor, DendronASTDest, DendronASTTypes, WikiLinkProps } from "../types";
import { MDUtilsV4 } from "../utils";
export { mdastBuilder };
export { select, selectAll } from "unist-util-select";
export declare const ALIAS_DIVIDER = "|";
export declare function addError(proc: Processor, err: DendronError): void;
export declare type NoteBlock = {
    /** The actual text of the block. */
    text: string;
    /** The anchor for this block, if one already exists. */
    anchor?: DNoteAnchorPositioned;
    /** The position within the document at which the block is located. */
    position: Position;
};
export declare function getNoteOrError(notes: NoteProps[], hint: any): {
    error: DendronError | undefined;
    note: undefined | NoteProps;
};
export declare type LinkFilter = {
    loc?: Partial<DNoteLoc>;
};
export declare class LinkUtils {
    static astType2DLinkType(type: DendronASTTypes): DLink["type"];
    static dlink2DNoteLink(link: DLink): DNoteLink;
    /**
     * Get all links from the note body
     * Currently, just look for wiki links
     * @param opts.filter - {type, loc
     *
     * - type: filter by {@link DendronASTTypes}
     * - loc: filter by {@link DLoc}
     */
    static findLinks({ note, engine, filter, }: {
        note: NoteProps;
        engine: DEngineClient;
        filter?: LinkFilter;
    }): DLink[];
    static isAlias(link: string): boolean;
    static hasFilter(link: string): boolean;
    static parseAliasLink(link: string): {
        alias: string;
        value: string;
    };
    static parseDendronURI(linkString: string): {
        vaultName: string;
        link: string;
    } | {
        link: string;
        vaultName?: undefined;
    };
    /** Either value or anchorHeader will always be present if the function did not
     *  return null. A missing value means that the file containing this link is
     *  the value.
     */
    static parseLinkV2(linkString: string): {
        alias?: string;
        value: string;
        anchorHeader?: string;
        vaultName?: string;
    } | {
        alias?: string;
        value?: string;
        anchorHeader: string;
        vaultName?: string;
    } | null;
    static parseLink(linkMatch: string): WikiLinkProps;
    static parseNoteRefRaw(ref: string): DNoteRefLinkRaw;
    static parseNoteRef(ref: string): DNoteRefLink;
    static renderNoteLink({ link, dest, }: {
        link: DNoteLink;
        dest: DendronASTDest;
    }): string | never;
    static updateLink({ note, oldLink, newLink, }: {
        note: NoteProps;
        oldLink: DNoteLink;
        newLink: DNoteLink;
    }): string;
}
export declare class AnchorUtils {
    /** Given a *parsed* anchor node, returns the anchor id ("header" or "^block" and positioned anchor object for it. */
    static anchorNode2anchor(node: Anchor, slugger: ReturnType<typeof getSlugger>): [string, DNoteAnchorPositioned] | undefined;
    static findAnchors(opts: {
        note: NoteProps;
        wsRoot: string;
    }, parseOpts: Parameters<typeof RemarkUtils.findAnchors>[1]): Promise<{
        [index: string]: DNoteAnchorPositioned;
    }>;
    static anchor2string(anchor: DNoteAnchor): string;
}
export declare class RemarkUtils {
    static bumpHeadings(root: Node, baseDepth: number): void;
    static findAnchors(content: string, opts: Omit<Parameters<typeof MDUtilsV4.procParse>[0], "dest">): Anchor[];
    static findIndex(array: Node[], fn: any): number;
    static isHeading(node: Node, text: string, depth?: number): boolean;
    static isNoteRefV2(node: Node): boolean;
    static convertLinksToDotNotation(note: NoteProps, changes: NoteChangeEntry[]): (this: Processor) => (tree: Node, _vfile: VFile) => void;
    static convertLinksFromDotNotation(note: NoteProps, changes: NoteChangeEntry[]): (this: Processor) => (tree: Node, _vfile: VFile) => void;
    static oldNoteRef2NewNoteRef(note: NoteProps, changes: NoteChangeEntry[]): (this: Processor) => (tree: Node, _vfile: VFile) => void;
    static h1ToTitle(note: NoteProps, changes: NoteChangeEntry[]): (this: Processor) => (tree: Node, _vfile: VFile) => void;
    static h1ToH2(note: NoteProps, changes: NoteChangeEntry[]): (this: Processor) => (tree: Node, _vfile: VFile) => void;
    /** Extract all blocks from the note which could be referenced by a block anchor.
     *
     * If those blocks already have anchors (or if they are a header), this will also find that anchor.
     *
     * @param note The note from which blocks will be extracted.
     */
    static extractBlocks({ note, wsRoot, engine, }: {
        note: NoteProps;
        wsRoot: string;
        engine: DEngineClient;
    }): Promise<NoteBlock[]>;
}
