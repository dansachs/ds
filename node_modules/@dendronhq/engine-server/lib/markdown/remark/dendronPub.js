"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.dendronPub = void 0;
const common_all_1 = require("@dendronhq/common-all");
const lodash_1 = __importDefault(require("lodash"));
const types_1 = require("../types");
const unist_builder_1 = __importDefault(require("unist-builder"));
const unist_util_visit_1 = __importDefault(require("unist-util-visit"));
const site_1 = require("../../topics/site");
const types_2 = require("../types");
const utils_1 = require("../utils");
const noteRefsV2_1 = require("./noteRefsV2");
const utils_2 = require("./utils");
const utils_3 = require("./utils");
const blockAnchors_1 = require("./blockAnchors");
function plugin(opts) {
    const proc = this;
    let { dest, vault, fname, config, overrides, insideNoteRef } = utils_1.MDUtilsV4.getDendronData(proc);
    function transformer(tree, _file) {
        let root = tree;
        const { error, engine } = utils_1.MDUtilsV4.getEngineFromProc(proc);
        const insertTitle = !lodash_1.default.isUndefined(overrides === null || overrides === void 0 ? void 0 : overrides.insertTitle)
            ? overrides === null || overrides === void 0 ? void 0 : overrides.insertTitle
            : opts === null || opts === void 0 ? void 0 : opts.insertTitle;
        if (!insideNoteRef && insertTitle && root.children) {
            if (!fname || !vault) {
                // TODO: tmp
                console.log(JSON.stringify(engine.notes));
                throw new common_all_1.DendronError({
                    message: `dendronPub - no fname or vault for node: ${JSON.stringify(tree)}`,
                });
            }
            const note = common_all_1.NoteUtils.getNoteByFnameV5({
                fname,
                notes: engine.notes,
                vault: vault,
                wsRoot: engine.wsRoot,
            });
            if (!note) {
                throw new common_all_1.DendronError({ message: `no note found for ${fname}` });
            }
            const idx = lodash_1.default.findIndex(root.children, (ent) => ent.type !== "yaml");
            root.children.splice(idx, 0, unist_builder_1.default(types_1.DendronASTTypes.HEADING, { depth: 1 }, [unist_builder_1.default("text", note.title)]));
        }
        unist_util_visit_1.default(tree, (node, index, parent) => {
            if (node.type === types_1.DendronASTTypes.WIKI_LINK &&
                dest !== types_2.DendronASTDest.MD_ENHANCED_PREVIEW) {
                let _node = node;
                let value = node.value;
                // we change this later
                let valueOrig = value;
                let isPublished = true;
                const data = _node.data;
                vault = utils_1.MDUtilsV4.getVault(proc, data.vaultName, {
                    vaultMissingBehavior: types_2.VaultMissingBehavior.FALLBACK_TO_ORIGINAL_VAULT,
                });
                if (error) {
                    utils_3.addError(proc, error);
                }
                const copts = opts === null || opts === void 0 ? void 0 : opts.wikiLinkOpts;
                if (opts === null || opts === void 0 ? void 0 : opts.transformNoPublish) {
                    const notes = common_all_1.NoteUtils.getNotesByFname({
                        fname: valueOrig,
                        notes: engine.notes,
                        vault,
                    });
                    const { error, note } = utils_3.getNoteOrError(notes, value);
                    if (error) {
                        value = "403";
                        utils_3.addError(proc, error);
                    }
                    else {
                        if (!note || !config) {
                            value = "403";
                            utils_3.addError(proc, new common_all_1.DendronError({ message: "no note or config" }));
                        }
                        else {
                            isPublished = site_1.SiteUtils.isPublished({
                                note,
                                config,
                                engine,
                            });
                            if (!isPublished) {
                                value = "403";
                            }
                        }
                    }
                }
                if ((copts === null || copts === void 0 ? void 0 : copts.useId) && isPublished) {
                    const notes = common_all_1.NoteUtils.getNotesByFname({
                        fname: valueOrig,
                        notes: engine.notes,
                        vault,
                    });
                    const { error, note } = utils_3.getNoteOrError(notes, value);
                    if (error) {
                        utils_3.addError(proc, error);
                    }
                    else {
                        value = note.id;
                    }
                }
                const alias = data.alias ? data.alias : value;
                const href = `${(copts === null || copts === void 0 ? void 0 : copts.prefix) || ""}${value}.html${data.anchorHeader ? "#" + data.anchorHeader : ""}`;
                const exists = true;
                // for rehype
                //_node.value = newValue;
                //_node.value = alias;
                _node.data = {
                    alias,
                    permalink: href,
                    exists: exists,
                    hName: "a",
                    hProperties: {
                        // className: classNames,
                        href,
                    },
                    hChildren: [
                        {
                            type: "text",
                            value: alias,
                        },
                    ],
                };
                if (value === "403") {
                    _node.data = {
                        alias,
                        hName: "a",
                        hProperties: {
                            "data-toggle": "popover",
                            title: "This page has not yet sprouted",
                            style: "cursor: pointer",
                            "data-content": [
                                `<a href="https://dendron.so/">Dendron</a> (the tool used to generate this site) lets authors selective publish content. You will see this page whenever you click on a link to an unpublished page`,
                                "",
                                "<img src='https://foundation-prod-assetspublic53c57cce-8cpvgjldwysl.s3-us-west-2.amazonaws.com/assets/images/not-sprouted.png'></img>",
                            ].join("\n"),
                        },
                        hChildren: [
                            {
                                type: "text",
                                value: alias,
                            },
                        ],
                    };
                }
            }
            if (node.type === types_1.DendronASTTypes.REF_LINK_V2) {
                // we have custom compiler for markdown to handle note ref
                const ndata = node.data;
                const copts = {
                    wikiLinkOpts: opts === null || opts === void 0 ? void 0 : opts.wikiLinkOpts,
                    prettyRefs: opts === null || opts === void 0 ? void 0 : opts.prettyRefs,
                };
                const procOpts = utils_1.MDUtilsV4.getProcOpts(proc);
                const { data } = noteRefsV2_1.convertNoteRefASTV2({
                    link: ndata.link,
                    proc,
                    compilerOpts: copts,
                    procOpts,
                });
                if (data) {
                    if (parent.children.length > 1) {
                        const children = parent.children;
                        const idx = utils_2.RemarkUtils.findIndex(children, utils_2.RemarkUtils.isNoteRefV2);
                        parent.children = children
                            .slice(0, idx)
                            .concat(data)
                            .concat(children.slice(idx + 1, -1));
                    }
                    else {
                        parent.children = data;
                    }
                }
            }
            if (node.type === types_1.DendronASTTypes.BLOCK_ANCHOR) {
                const procOpts = utils_1.MDUtilsV4.getProcOpts(proc);
                parent.children[index] = blockAnchors_1.blockAnchor2html(node, procOpts.blockAnchorsOpts);
            }
            if (node.type === "image" && dest === types_2.DendronASTDest.HTML) {
                let imageNode = node;
                if (opts === null || opts === void 0 ? void 0 : opts.assetsPrefix) {
                    imageNode.url =
                        "/" +
                            lodash_1.default.trim(opts.assetsPrefix, "/") +
                            "/" +
                            lodash_1.default.trim(imageNode.url, "/");
                }
            }
        });
        return tree;
    }
    return transformer;
}
exports.dendronPub = plugin;
//# sourceMappingURL=dendronPub.js.map