"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RemarkUtils = exports.AnchorUtils = exports.LinkUtils = exports.getNoteOrError = exports.addError = exports.ALIAS_DIVIDER = exports.selectAll = exports.select = exports.mdastBuilder = void 0;
const common_all_1 = require("@dendronhq/common-all");
const common_all_2 = require("@dendronhq/common-all");
const common_server_1 = require("@dendronhq/common-server");
const lodash_1 = __importDefault(require("lodash"));
const mdastBuilder = __importStar(require("mdast-builder"));
exports.mdastBuilder = mdastBuilder;
const unist_util_select_1 = require("unist-util-select");
const unist_util_visit_1 = __importDefault(require("unist-util-visit"));
const utils_1 = require("../../utils");
const types_1 = require("../types");
const utils_2 = require("../utils");
const utilsv5_1 = require("../utilsv5");
const toString = require("mdast-util-to-string");
var unist_util_select_2 = require("unist-util-select");
Object.defineProperty(exports, "select", { enumerable: true, get: function () { return unist_util_select_2.select; } });
Object.defineProperty(exports, "selectAll", { enumerable: true, get: function () { return unist_util_select_2.selectAll; } });
exports.ALIAS_DIVIDER = "|";
function addError(proc, err) {
    const errors = proc.data("errors");
    errors.push(err);
    proc().data("errors", errors);
}
exports.addError = addError;
function getNoteOrError(notes, hint) {
    let error;
    let note;
    if (lodash_1.default.isUndefined(notes)) {
        error = new common_all_2.DendronError({ message: `no note found. ${hint}` });
        return { error, note };
    }
    if (notes.length > 1) {
        error = new common_all_2.DendronError({
            message: `multiple notes found for link: ${hint}`,
        });
        return { error, note };
    }
    if (notes.length < 1) {
        error = new common_all_2.DendronError({
            message: `no notes found for link: ${JSON.stringify(hint)}`,
        });
        return { error, note };
    }
    note = notes[0];
    return { error, note };
}
exports.getNoteOrError = getNoteOrError;
const getLinks = ({ ast, note, filter, }) => {
    const wikiLinks = [];
    const noteRefs = [];
    unist_util_visit_1.default(ast, [
        types_1.DendronASTTypes.WIKI_LINK,
        types_1.DendronASTTypes.REF_LINK_V2,
        types_1.DendronASTTypes.REF_LINK,
    ], (node) => {
        switch (node.type) {
            case types_1.DendronASTTypes.WIKI_LINK:
                wikiLinks.push(node);
                break;
            case types_1.DendronASTTypes.REF_LINK_V2:
                noteRefs.push(node);
                break;
            case types_1.DendronASTTypes.REF_LINK:
                noteRefs.push(node);
                break;
        }
    });
    const dlinks = [];
    for (const wikiLink of wikiLinks) {
        dlinks.push({
            type: LinkUtils.astType2DLinkType(wikiLink.type),
            from: common_all_2.NoteUtils.toNoteLoc(note),
            value: wikiLink.value,
            alias: wikiLink.data.alias,
            position: wikiLink.position,
            xvault: !lodash_1.default.isUndefined(wikiLink.data.vaultName),
            // TODO: error if vault not found
            to: {
                fname: wikiLink.value,
                anchorHeader: wikiLink.data.anchorHeader,
                vaultName: wikiLink.data.vaultName,
            },
        });
    }
    // the cast is safe because the only difference is whether `data.vaultName` exists, which is already optional
    for (const noteRef of noteRefs) {
        const { anchorStart, anchorEnd, anchorStartOffset } = noteRef.data.link.data;
        const anchorStartText = anchorStart ? anchorStart : "";
        const anchorStartOffsetText = anchorStartOffset
            ? `,${anchorStartOffset}`
            : "";
        const anchorEndText = anchorEnd ? `:#${anchorEnd}` : "";
        const anchorHeader = `${anchorStartText}${anchorStartOffsetText}${anchorEndText}`;
        dlinks.push({
            type: LinkUtils.astType2DLinkType(noteRef.type),
            from: common_all_2.NoteUtils.toNoteLoc(note),
            value: noteRef.data.link.from.fname,
            // not sure why typescript doesn't recognize the position, but I can confirm it exists in the debugger
            position: noteRef.position,
            xvault: !lodash_1.default.isUndefined(noteRef.data.link.data.vaultName),
            // TODO: error if vault not found
            to: {
                fname: noteRef.data.link.from.fname,
                anchorHeader: anchorHeader ? anchorHeader : undefined,
                vaultName: noteRef.data.link.data.vaultName,
            },
        });
    }
    if (filter === null || filter === void 0 ? void 0 : filter.loc) {
        // TODO: add additional filters besides fname
        return dlinks.filter((ent) => {
            var _a;
            return ent.value === ((_a = filter === null || filter === void 0 ? void 0 : filter.loc) === null || _a === void 0 ? void 0 : _a.fname);
        });
    }
    return dlinks;
};
class LinkUtils {
    static astType2DLinkType(type) {
        switch (type) {
            case types_1.DendronASTTypes.WIKI_LINK:
                return "wiki";
            case types_1.DendronASTTypes.REF_LINK:
            case types_1.DendronASTTypes.REF_LINK_V2:
                return "ref";
            default:
                throw new common_all_2.DendronError({ message: `invalid type conversion: ${type}` });
        }
    }
    static dlink2DNoteLink(link) {
        var _a;
        return {
            data: {
                xvault: link.xvault,
            },
            from: {
                fname: link.value,
                alias: link.alias,
                anchorHeader: (_a = link.to) === null || _a === void 0 ? void 0 : _a.anchorHeader,
                vaultName: link.from.vaultName,
            },
            type: link.type,
            position: link.position,
        };
    }
    /**
     * Get all links from the note body
     * Currently, just look for wiki links
     * @param opts.filter - {type, loc
     *
     * - type: filter by {@link DendronASTTypes}
     * - loc: filter by {@link DLoc}
     */
    static findLinks({ note, engine, filter, }) {
        const content = note.body;
        let remark = utilsv5_1.MDUtilsV5.procRemarkParse({ mode: utilsv5_1.ProcMode.FULL }, {
            engine,
            fname: note.fname,
            vault: note.vault,
            dest: types_1.DendronASTDest.MD_DENDRON,
        });
        let out = remark.parse(content);
        const links = getLinks({
            ast: out,
            filter: { loc: filter === null || filter === void 0 ? void 0 : filter.loc },
            note,
        });
        return links;
    }
    static isAlias(link) {
        return link.indexOf("|") !== -1;
    }
    static hasFilter(link) {
        return link.indexOf(">") !== -1;
    }
    static parseAliasLink(link) {
        const [alias, value] = link.split("|").map(lodash_1.default.trim);
        return { alias, value: common_all_2.NoteUtils.normalizeFname(value) };
    }
    static parseDendronURI(linkString) {
        if (linkString.startsWith(common_all_2.CONSTANTS.DENDRON_DELIMETER)) {
            const [vaultName, link] = linkString
                .split(common_all_2.CONSTANTS.DENDRON_DELIMETER)[1]
                .split("/");
            return {
                vaultName,
                link,
            };
        }
        return {
            link: linkString,
        };
    }
    /** Either value or anchorHeader will always be present if the function did not
     *  return null. A missing value means that the file containing this link is
     *  the value.
     */
    static parseLinkV2(linkString) {
        const LINK_NAME = "[^#\\|>]+";
        // aliases may contain # symbols
        const ALIAS_NAME = "[^\\|>]+";
        const re = new RegExp("" +
            // alias?
            `(` +
            `(?<alias>${ALIAS_NAME}(?=\\|))` +
            "\\|" +
            ")?" +
            // name
            `(?<value>${LINK_NAME})?` +
            // anchor?
            `(#(?<anchor>${LINK_NAME}))?` +
            // filters?
            `(>(?<filtersRaw>.*))?`, "i");
        const out = linkString.match(re);
        if (out) {
            let { alias, value, anchor } = out.groups;
            if (!value && !anchor)
                return null; // Does not actually link to anything
            let vaultName;
            if (value) {
                ({ vaultName, link: value } = this.parseDendronURI(value));
                if (!alias) {
                    alias = value;
                }
                alias = lodash_1.default.trim(alias);
                value = lodash_1.default.trim(value);
            }
            return { alias, value, anchorHeader: anchor, vaultName };
        }
        else {
            return null;
        }
    }
    static parseLink(linkMatch) {
        linkMatch = common_all_2.NoteUtils.normalizeFname(linkMatch);
        let out = {
            value: linkMatch,
            alias: linkMatch,
        };
        if (LinkUtils.isAlias(linkMatch)) {
            out = LinkUtils.parseAliasLink(linkMatch);
        }
        if (out.value.indexOf("#") !== -1) {
            const [value, anchorHeader] = out.value.split("#").map(lodash_1.default.trim);
            out.value = value;
            out.anchorHeader = anchorHeader;
            // if we didn't have an alias, links with a # anchor shouldn't have # portion be in the title
            if (!LinkUtils.isAlias(linkMatch)) {
                out.alias = value;
            }
        }
        return out;
    }
    static parseNoteRefRaw(ref) {
        var _a;
        const optWikiFileName = /([^\]:#]*)/.source;
        const wikiFileName = /([^\]:#]+)/.source;
        const reLink = new RegExp("" +
            `(?<name>${optWikiFileName})` +
            `(${new RegExp(
            // anchor start
            "" +
                /#?/.source +
                `(?<anchorStart>${wikiFileName})` +
                // anchor stop
                `(:#(?<anchorEnd>${wikiFileName}))?`).source})?`, "i");
        // pre-parse alias if it exists
        let alias;
        const [aliasPartFirst, aliasPartSecond] = ref.split("|");
        if (lodash_1.default.isUndefined(aliasPartSecond))
            ref = aliasPartFirst;
        else {
            alias = aliasPartFirst;
            ref = aliasPartSecond;
        }
        // pre-parse vault name if it exists
        let vaultName = undefined;
        ({ vaultName, link: ref } = LinkUtils.parseDendronURI(ref));
        const groups = (_a = reLink.exec(ref)) === null || _a === void 0 ? void 0 : _a.groups;
        const clean = {
            type: "file",
        };
        let fname;
        lodash_1.default.each(groups, (v, k) => {
            var _a, _b;
            if (lodash_1.default.isUndefined(v)) {
                return;
            }
            if (k === "name") {
                // remove .md extension if it exists, but keep full path in case this is an image
                fname = (_b = (_a = /^(?<name>.*?)(\.md)?$/.exec(lodash_1.default.trim(v))) === null || _a === void 0 ? void 0 : _a.groups) === null || _b === void 0 ? void 0 : _b.name;
            }
            else {
                // @ts-ignore
                clean[k] = v;
            }
        });
        if (clean.anchorStart && clean.anchorStart.indexOf(",") >= 0) {
            const [anchorStart, offset] = clean.anchorStart.split(",");
            clean.anchorStart = anchorStart;
            clean.anchorStartOffset = parseInt(offset);
        }
        if (lodash_1.default.isUndefined(fname) && lodash_1.default.isUndefined(clean.anchorStart)) {
            throw new common_all_2.DendronError({
                message: `both fname and anchorStart for ${ref} is undefined`,
            });
        }
        if (vaultName) {
            clean.vaultName = vaultName;
        }
        // TODO
        // @ts-ignore
        return { from: { fname, alias }, data: clean, type: "ref" };
    }
    static parseNoteRef(ref) {
        var _a;
        const noteRef = LinkUtils.parseNoteRefRaw(ref);
        if (lodash_1.default.isUndefined((_a = noteRef.from) === null || _a === void 0 ? void 0 : _a.fname) &&
            lodash_1.default.isUndefined(noteRef.data.anchorStart)) {
            throw new common_all_2.DendronError({
                message: `both fname and anchorStart for ${ref} is undefined`,
            });
        }
        // @ts-ignore
        return noteRef;
    }
    static renderNoteLink({ link, dest, }) {
        switch (dest) {
            case types_1.DendronASTDest.MD_DENDRON: {
                const ref = link.type === "ref" ? "!" : "";
                const vaultPrefix = link.from.vaultName && link.data.xvault
                    ? `${common_all_2.CONSTANTS.DENDRON_DELIMETER}${link.from.vaultName}/`
                    : "";
                const value = link.from.fname;
                const alias = !lodash_1.default.isUndefined(link.from.alias) && link.from.alias !== value
                    ? link.from.alias + "|"
                    : undefined;
                const anchor = link.from.anchorHeader
                    ? `#${link.from.anchorHeader}`
                    : "";
                // TODO: take into account piping direction
                return [ref, `[[`, alias, vaultPrefix, value, anchor, `]]`].join("");
            }
            default:
                return common_all_2.assertUnreachable();
        }
    }
    static updateLink({ note, oldLink, newLink, }) {
        const { start, end } = oldLink.position;
        const startOffset = start.offset;
        const endOffset = end.offset;
        const body = note.body;
        const newBody = [
            body.slice(0, startOffset),
            LinkUtils.renderNoteLink({
                link: newLink,
                dest: types_1.DendronASTDest.MD_DENDRON,
            }),
            body.slice(endOffset),
        ].join("");
        return newBody;
    }
}
exports.LinkUtils = LinkUtils;
class AnchorUtils {
    /** Given a *parsed* anchor node, returns the anchor id ("header" or "^block" and positioned anchor object for it. */
    static anchorNode2anchor(node, slugger) {
        if (lodash_1.default.isUndefined(node.position))
            return undefined;
        const { line, column } = node.position.start;
        if (node.type === types_1.DendronASTTypes.HEADING) {
            const value = slugger.slug(node.children[0].value);
            return [
                value,
                {
                    type: "header",
                    value,
                    line: line - 1,
                    column: column - 1,
                },
            ];
        }
        else if (node.type === types_1.DendronASTTypes.BLOCK_ANCHOR) {
            return [
                `^${node.id}`,
                {
                    type: "block",
                    value: node.id,
                    line: line - 1,
                    column: column - 1,
                },
            ];
        }
        else {
            common_all_2.assertUnreachable(node);
        }
    }
    static async findAnchors(opts, parseOpts) {
        if (opts.note.stub)
            return {};
        try {
            const noteContents = await common_server_1.note2String(opts);
            const noteAnchors = RemarkUtils.findAnchors(noteContents, parseOpts);
            const slugger = common_all_2.getSlugger();
            const anchors = noteAnchors
                .map((anchor) => this.anchorNode2anchor(anchor, slugger))
                .filter(common_all_1.isNotUndefined);
            return Object.fromEntries(anchors);
        }
        catch (err) {
            const error = common_all_2.DendronError.createFromStatus({
                status: common_all_2.ERROR_STATUS.UNKNOWN,
                payload: { note: common_all_2.NoteUtils.toLogObj(opts.note), wsRoot: opts.wsRoot },
                error: err,
            });
            common_server_1.createLogger("AnchorUtils").error(error);
            return {};
        }
    }
    static anchor2string(anchor) {
        if (anchor.type === "block")
            return `^${anchor.value}`;
        if (anchor.type === "header")
            return anchor.value;
        common_all_2.assertUnreachable(anchor.type);
    }
}
exports.AnchorUtils = AnchorUtils;
function walk(node, fn) {
    fn(node);
    if (node.children) {
        node.children.forEach(function (n) {
            walk(n, fn);
        });
    }
}
const MAX_HEADING_DEPTH = 99999;
const NODE_TYPES_TO_EXTRACT = [
    types_1.DendronASTTypes.BLOCK_ANCHOR,
    types_1.DendronASTTypes.HEADING,
    types_1.DendronASTTypes.LIST,
    types_1.DendronASTTypes.LIST_ITEM,
    types_1.DendronASTTypes.TABLE,
    types_1.DendronASTTypes.PARAGRAPH,
];
class RemarkUtils {
    static bumpHeadings(root, baseDepth) {
        var headings = [];
        walk(root, function (node) {
            if (node.type === types_1.DendronASTTypes.HEADING) {
                headings.push(node);
            }
        });
        var minDepth = headings.reduce(function (memo, h) {
            return Math.min(memo, h.depth);
        }, MAX_HEADING_DEPTH);
        var diff = baseDepth + 1 - minDepth;
        headings.forEach(function (h) {
            h.depth += diff;
        });
    }
    static findAnchors(content, opts) {
        const parser = utils_2.MDUtilsV4.procParse({
            dest: types_1.DendronASTDest.MD_DENDRON,
            ...opts,
        });
        const parsed = parser.parse(content);
        return [
            ...unist_util_select_1.selectAll(types_1.DendronASTTypes.HEADING, parsed),
            ...unist_util_select_1.selectAll(types_1.DendronASTTypes.BLOCK_ANCHOR, parsed),
        ];
    }
    static findIndex(array, fn) {
        for (var i = 0; i < array.length; i++) {
            if (fn(array[i], i)) {
                return i;
            }
        }
        return -1;
    }
    static isHeading(node, text, depth) {
        if (node.type !== types_1.DendronASTTypes.HEADING) {
            return false;
        }
        // wildcard is always true
        if (text === "*") {
            return true;
        }
        if (text) {
            var headingText = toString(node);
            return text.trim().toLowerCase() === headingText.trim().toLowerCase();
        }
        if (depth) {
            return node.depth <= depth;
        }
        return true;
    }
    static isNoteRefV2(node) {
        return node.type === types_1.DendronASTTypes.REF_LINK_V2;
    }
    // --- conversion
    static convertLinksToDotNotation(note, changes) {
        return function () {
            return (tree, _vfile) => {
                let root = tree;
                let wikiLinks = unist_util_select_1.selectAll(types_1.DendronASTTypes.WIKI_LINK, root);
                wikiLinks.forEach((linkNode) => {
                    if (linkNode.value.indexOf("/") >= 0) {
                        const newValue = lodash_1.default.replace(linkNode.value, /\//g, ".");
                        if (linkNode.data.alias === linkNode.value) {
                            linkNode.data.alias = newValue;
                        }
                        linkNode.value = newValue;
                        changes.push({
                            note: note,
                            status: "update",
                        });
                    }
                });
            };
        };
    }
    static convertLinksFromDotNotation(note, changes) {
        return function () {
            return (tree, _vfile) => {
                let root = tree;
                let wikiLinks = unist_util_select_1.selectAll(types_1.DendronASTTypes.WIKI_LINK, root);
                let dirty = false;
                wikiLinks.forEach((linkNode) => {
                    if (linkNode.value.indexOf(".") >= 0) {
                        const newValue = lodash_1.default.replace(linkNode.value, /\./g, "/");
                        if (linkNode.data.alias === linkNode.value) {
                            linkNode.data.alias = newValue;
                        }
                        linkNode.value = newValue;
                        dirty = true;
                    }
                });
                //TODO: Add support for Ref Notes and Block Links
                if (dirty) {
                    changes.push({
                        note: note,
                        status: "update",
                    });
                }
            };
        };
    }
    static oldNoteRef2NewNoteRef(note, changes) {
        return function () {
            return (tree, _vfile) => {
                let root = tree;
                //@ts-ignore
                let notesRefLegacy = unist_util_select_1.selectAll(types_1.DendronASTTypes.REF_LINK, root);
                notesRefLegacy.map((noteRefLegacy) => {
                    const slugger = common_all_2.getSlugger();
                    // @ts-ignore;
                    noteRefLegacy.type = types_1.DendronASTTypes.REF_LINK_V2;
                    const { anchorStart, anchorEnd } = noteRefLegacy.data.link.data;
                    if (anchorStart) {
                        noteRefLegacy.data.link.data.anchorStart = utils_1.normalizev2(anchorStart, slugger);
                    }
                    if (anchorEnd) {
                        noteRefLegacy.data.link.data.anchorEnd = utils_1.normalizev2(anchorEnd, slugger);
                    }
                });
                if (!lodash_1.default.isEmpty(notesRefLegacy)) {
                    changes.push({
                        note,
                        status: "update",
                    });
                }
            };
        };
    }
    static h1ToTitle(note, changes) {
        return function () {
            return (tree, _vfile) => {
                let root = tree;
                const idx = lodash_1.default.findIndex(root.children, (ent) => ent.type === types_1.DendronASTTypes.HEADING && ent.depth === 1);
                if (idx >= 0) {
                    const head = root.children.splice(idx, 1)[0];
                    if (head.children.length === 1 && head.children[0].type === "text") {
                        note.title = head.children[0].value;
                    }
                    changes.push({
                        note,
                        status: "update",
                    });
                }
            };
        };
    }
    static h1ToH2(note, changes) {
        return function () {
            return (tree, _vfile) => {
                let root = tree;
                const idx = lodash_1.default.findIndex(root.children, (ent) => ent.type === types_1.DendronASTTypes.HEADING && ent.depth === 1);
                if (idx >= 0) {
                    const head = root.children[idx];
                    head.depth = 2;
                    changes.push({
                        note,
                        status: "update",
                    });
                }
            };
        };
    }
    /** Extract all blocks from the note which could be referenced by a block anchor.
     *
     * If those blocks already have anchors (or if they are a header), this will also find that anchor.
     *
     * @param note The note from which blocks will be extracted.
     */
    static async extractBlocks({ note, wsRoot, engine, }) {
        const proc = utilsv5_1.MDUtilsV5.procRemarkFull({
            engine,
            vault: note.vault,
            fname: note.fname,
            dest: types_1.DendronASTDest.MD_DENDRON,
        });
        const slugger = common_all_2.getSlugger();
        // Read and parse the note
        // TODO: It might be better to get the text from the editor
        const noteText = await common_server_1.note2String({ note, wsRoot });
        const noteAST = proc.parse(noteText);
        if (lodash_1.default.isUndefined(noteAST.children))
            return [];
        const nodesToSearch = lodash_1.default.filter(noteAST.children, (node) => lodash_1.default.includes(NODE_TYPES_TO_EXTRACT, node.type));
        // Extract the blocks
        const blocks = [];
        for (const node of nodesToSearch) {
            // Block anchors at top level refer to the blocks before them
            if (node.type === types_1.DendronASTTypes.PARAGRAPH) {
                // These look like a paragraph...
                const parent = node;
                if (parent.children.length === 1) {
                    // ... that has only a block anchor in it ...
                    const child = parent.children[0];
                    if (child.type === types_1.DendronASTTypes.BLOCK_ANCHOR) {
                        // ... in which case this block anchor refers to the previous block, if any
                        const previous = lodash_1.default.last(blocks);
                        if (!lodash_1.default.isUndefined(previous))
                            [, previous.anchor] =
                                AnchorUtils.anchorNode2anchor(child, slugger) ||
                                    [];
                        // Block anchors themselves are not blocks, don't extract them
                        continue;
                    }
                }
            }
            // Extract list items out of lists. We also extract them from nested lists,
            // because block anchors can't refer to nested lists, only items inside of them
            if (node.type === types_1.DendronASTTypes.LIST) {
                unist_util_visit_1.default(node, [types_1.DendronASTTypes.LIST_ITEM], (listItem) => {
                    // The list item might have a block anchor inside of it.
                    let anchor;
                    unist_util_visit_1.default(listItem, [types_1.DendronASTTypes.BLOCK_ANCHOR, types_1.DendronASTTypes.LIST], (inListItem) => {
                        // Except if we hit a nested list, because then the block anchor refers to the item in the nested list
                        if (inListItem.type === types_1.DendronASTTypes.LIST)
                            return "skip";
                        [, anchor] =
                            AnchorUtils.anchorNode2anchor(inListItem, slugger) || [];
                        return;
                    });
                    blocks.push({
                        text: proc.stringify(listItem),
                        anchor,
                        // position can only be undefined for generated nodes, not for parsed ones
                        position: listItem.position,
                    });
                });
            }
            // extract the anchor for this block, if it exists
            let anchor;
            if (node.type === types_1.DendronASTTypes.HEADING) {
                // Headings are anchors themselves
                [, anchor] =
                    AnchorUtils.anchorNode2anchor(node, slugger) || [];
            }
            else if (node.type !== types_1.DendronASTTypes.LIST) {
                // Other nodes might have block anchors inside them
                // Except lists, because anchors inside lists only refer to specific list items
                unist_util_visit_1.default(node, [types_1.DendronASTTypes.BLOCK_ANCHOR], (child) => {
                    [, anchor] =
                        AnchorUtils.anchorNode2anchor(child, slugger) || [];
                });
            }
            // extract the block
            blocks.push({
                text: proc.stringify(node),
                anchor,
                // position can only be undefined for generated nodes, not for parsed ones
                position: node.position,
            });
        }
        return blocks;
    }
}
exports.RemarkUtils = RemarkUtils;
//# sourceMappingURL=utils.js.map