"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.backlinks = void 0;
const common_all_1 = require("@dendronhq/common-all");
const lodash_1 = __importDefault(require("lodash"));
const mdast_builder_1 = require("mdast-builder");
const unist_builder_1 = __importDefault(require("unist-builder"));
const types_1 = require("../types");
const utils_1 = require("../utils");
// Plugin that adds backlinks at the end of each page if they exist
const plugin = function () {
    const proc = this;
    function transformer(tree) {
        let root = tree;
        const { fname, vault, dest, insideNoteRef } = utils_1.MDUtilsV4.getDendronData(proc);
        if (!fname || insideNoteRef) {
            return;
        }
        if (dest !== types_1.DendronASTDest.HTML) {
            return;
        }
        const { engine } = utils_1.MDUtilsV4.getEngineFromProc(proc);
        const note = common_all_1.NoteUtils.getNoteByFnameV5({
            fname: fname,
            notes: engine.notes,
            vault: vault,
            wsRoot: engine.wsRoot,
        });
        const backlinks = lodash_1.default.uniqBy(((note === null || note === void 0 ? void 0 : note.links) || []).filter((ent) => ent.type === "backlink"), (ent) => ent.from.fname + (ent.from.vaultName || ""));
        if (!lodash_1.default.isEmpty(backlinks)) {
            root.children.push({
                type: "thematicBreak",
            });
            root.children.push(unist_builder_1.default(types_1.DendronASTTypes.HEADING, { depth: 2 }, [unist_builder_1.default("text", "Backlinks")]));
            root.children.push(mdast_builder_1.list("unordered", backlinks.map((mdLink) => {
                return mdast_builder_1.listItem(mdast_builder_1.paragraph({
                    type: types_1.DendronASTTypes.WIKI_LINK,
                    value: mdLink.from.fname,
                    data: {
                        alias: common_all_1.NoteUtils.getNoteOrThrow({
                            fname: mdLink.from.fname,
                            notes: engine.notes,
                            vault: common_all_1.VaultUtils.getVaultByName({
                                vaults: engine.vaults,
                                vname: mdLink.from.vaultName,
                            }),
                            wsRoot: engine.wsRoot,
                        }).title +
                            (engine.vaults.length > 1
                                ? ` (${mdLink.from.vaultName})`
                                : ""),
                        vaultName: mdLink.from.vaultName,
                    },
                    children: [],
                }));
            })));
        }
        // end transformer
    }
    return transformer;
};
exports.backlinks = plugin;
//# sourceMappingURL=backlinks.js.map