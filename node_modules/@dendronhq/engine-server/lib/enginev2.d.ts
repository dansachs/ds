import { BulkAddNoteOpts, ConfigWriteOpts, DendronConfig, DEngine, DEngineClient, DEngineDeleteSchemaResp, DEngineInitResp, DEngineMode, DHookDict, DLink, DNodeType, DStore, DVault, EngineDeleteOptsV2, EngineUpdateNodesOptsV2, EngineWriteOptsV2, GetNoteOptsV2, GetNotePayload, NoteChangeEntry, NoteProps, NotePropsDict, QueryNotesOpts, RenameNoteOpts, RenameNotePayload, RenderNoteOpts, RenderNotePayload, RespV2, SchemaModuleDict, SchemaModuleProps, SchemaQueryResp, WorkspaceOpts, WriteNoteResp } from "@dendronhq/common-all";
import { DLogger } from "@dendronhq/common-server";
import { FuseEngine } from "./fuseEngine";
declare type CreateStoreFunc = (engine: DEngineClient) => DStore;
declare type DendronEngineOptsV2 = {
    wsRoot: string;
    vaults: DVault[];
    forceNew?: boolean;
    createStore?: CreateStoreFunc;
    mode?: DEngineMode;
    logger?: DLogger;
    config: DendronConfig;
};
declare type DendronEnginePropsV2 = Required<DendronEngineOptsV2>;
export declare class DendronEngineV2 implements DEngine {
    wsRoot: string;
    store: DStore;
    protected props: DendronEnginePropsV2;
    logger: DLogger;
    fuseEngine: FuseEngine;
    links: DLink[];
    configRoot: string;
    config: DendronConfig;
    hooks: DHookDict;
    private _vaults;
    static _instance: DendronEngineV2 | undefined;
    constructor(props: DendronEnginePropsV2);
    static create({ wsRoot, logger }: {
        logger?: DLogger;
        wsRoot: string;
    }): DendronEngineV2;
    static instance({ wsRoot }: {
        wsRoot: string;
    }): DendronEngineV2;
    get notes(): NotePropsDict;
    get schemas(): SchemaModuleDict;
    get vaults(): DVault[];
    set notes(notes: NotePropsDict);
    set vaults(vaults: DVault[]);
    /**
     * Does not throw error but returns it
     */
    init(): Promise<DEngineInitResp>;
    bulkAddNotes(opts: BulkAddNoteOpts): Promise<Required<RespV2<NoteChangeEntry[]>>>;
    deleteNote(id: string, opts?: EngineDeleteOptsV2): ReturnType<DEngineClient["deleteNote"]>;
    deleteSchema(id: string, opts?: EngineDeleteOptsV2): Promise<DEngineDeleteSchemaResp>;
    getNoteByPath({ npath, createIfNew, vault, overrides, }: GetNoteOptsV2): Promise<RespV2<GetNotePayload>>;
    getConfig(): Promise<{
        error: null;
        data: DendronConfig;
    }>;
    getSchema(id: string): Promise<RespV2<SchemaModuleProps>>;
    info(): Promise<{
        data: {
            version: string;
        };
        error: null;
    }>;
    queryNotesSync({ qs, }: {
        qs: string;
    }): ReturnType<DEngineClient["queryNotesSync"]>;
    querySchema(queryString: string): Promise<SchemaQueryResp>;
    queryNotes(opts: QueryNotesOpts): ReturnType<DEngineClient["queryNotes"]>;
    renderNote({ id }: RenderNoteOpts): Promise<RespV2<RenderNotePayload>>;
    sync(): Promise<any>;
    refreshNotesV2(notes: NoteChangeEntry[]): Promise<void>;
    renameNote(opts: RenameNoteOpts): Promise<RespV2<RenameNotePayload>>;
    updateNote(note: NoteProps, opts?: EngineUpdateNodesOptsV2): Promise<NoteProps>;
    updateIndex(mode: DNodeType): Promise<void>;
    updateSchema(schemaModule: SchemaModuleProps): Promise<void>;
    writeConfig(opts: ConfigWriteOpts): ReturnType<DEngine["writeConfig"]>;
    writeNote(note: NoteProps, opts?: EngineWriteOptsV2): Promise<WriteNoteResp>;
    writeSchema(schema: SchemaModuleProps): Promise<void>;
}
export declare const createEngine: ({ wsRoot }: WorkspaceOpts) => DEngineClient;
export {};
