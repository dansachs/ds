import { DendronError, IDendronError } from "../error";
import { DLink, DNodeProps, DNodeType, NoteProps, Position, SchemaData, SchemaProps } from "./foundation";
import { DHookDict } from "./hooks";
import { DendronConfig, DVault } from "./workspace";
export declare enum ResponseCode {
    OK = 200,
    PRECONDITION_FAILED = 412
}
export declare type EngineDeleteOpts = {
    /**
     * Only delete from meta
     */
    metaOnly?: boolean;
    /**
     * If node is deleted and parents are stubs, default behavior is to alsod elete parents
     */
    noDeleteParentStub?: boolean;
};
export declare type NoteLink = {
    type: "note";
    id: string;
};
export declare type DNoteLoc = {
    fname: string;
    alias?: string;
    id?: string;
    vaultName?: string;
    anchorHeader?: string;
};
export declare type DNoteAnchor = {
    /**
     * In the future, we could have ID based anchors
     */
    type: "header" | "block";
    value: string;
};
export declare type DNoteAnchorPositioned = DNoteAnchor & {
    line: number;
    column: number;
};
export declare type DLinkType = "wiki" | "refv2";
export declare type DNoteLinkData = {
    xvault?: boolean;
};
export declare type DNoteLink<TData extends DNoteLinkData = DNoteLinkData> = {
    type: "ref" | "wiki" | "md" | "backlink";
    position?: Position;
    from: DNoteLoc;
    to?: DNoteLoc;
    data: TData;
};
export declare type DNoteLinkRaw<TData = any> = Omit<DNoteLink<TData>, "from"> & {
    from?: DNoteLoc;
};
export declare type DNoteRefData = {
    anchorStart?: string;
    anchorEnd?: string;
    anchorStartOffset?: number;
    vaultName?: string;
    /**
     * File link: wiki based links (eg. [[foo]])
     * Id link: TBD (eg. ^1234)
     */
    type: "file" | "id";
} & DNoteLinkData;
export declare type DNoteRefLink = DNoteLink<DNoteRefData>;
export declare type DNoteRefLinkRaw = DNoteLinkRaw<DNoteRefData>;
/**
 * Opts are arguments used when creating a node
 */
export declare type DNodeOpts<T = any> = Partial<Omit<DNodeProps<T>, "fname|type|vault">> & {
    fname: string;
    type: DNodeType;
    vault: DVault;
};
export declare type SchemaRaw = Pick<SchemaProps, "id"> & Partial<SchemaData> & {
    title?: string;
    desc?: string;
} & Partial<Pick<DNodeProps, "children">>;
export declare type SchemaOpts = Omit<DNodeOpts<SchemaData>, "type" | "id"> & {
    id: string;
};
export declare type NoteOpts = Omit<DNodeOpts, "type">;
export declare type DNodePropsQuickInputV2<T = any> = DNodeProps<T> & {
    label: string;
    detail?: string;
    alwaysShow?: boolean;
};
export declare type NoteQuickInput = NoteProps & {
    label: string;
    detail?: string;
    alwaysShow?: boolean;
};
export declare type DNodePropsDict = {
    [key: string]: DNodeProps;
};
export declare type NotePropsDict = {
    [key: string]: NoteProps;
};
export declare type SchemaPropsDict = {
    [key: string]: SchemaProps;
};
export declare type SchemaModuleDict = {
    [key: string]: SchemaModuleProps;
};
export declare type SchemaImport = string[];
export declare type SchemaModuleOpts = {
    version: number;
    imports?: SchemaImport;
    schemas: SchemaOpts[];
};
export declare type SchemaModuleProps = {
    version: number;
    imports?: SchemaImport;
    schemas: SchemaPropsDict;
    root: SchemaProps;
    fname: string;
    vault: DVault;
};
export interface RespV2<T> {
    data?: T;
    error: IDendronError | null;
}
export declare type RespRequired<T> = {
    error: null | undefined;
    data: T;
} | {
    error: DendronError;
    data: undefined;
};
export interface QueryOptsV2 {
    /**
     * Should add to full nodes
     */
    fullNode?: boolean;
    /**
     * Just get one result
     */
    queryOne?: boolean;
    /**
     * If node does not exist, create it?
     */
    createIfNew?: boolean;
}
export declare type EngineUpdateNodesOptsV2 = {
    /**
     * New Node, should add to `fullNode` cache
     */
    newNode: boolean;
};
export declare type GetNoteOptsV2 = {
    vault: DVault;
    npath: string;
    /**
     * If node does not exist, create it?
     */
    createIfNew?: boolean;
    /**
     * Override any props
     */
    overrides?: Partial<NoteProps>;
};
export declare type EngineDeleteOptsV2 = EngineDeleteOpts;
export declare type EngineWriteOptsV2 = {
    /**
     * Write all children?
     * default: false
     */
    recursive?: boolean;
    /**
     * Should persist hierarchy information to disk
     */
    writeHierarchy?: boolean;
    /**
     * Don't bother adding parent nodes.
     * Used when importing existing notes in bulk
     */
    noAddParent?: boolean;
    /**
     * Should update existing note instead of overwriting
     */
    updateExisting?: boolean;
} & Partial<EngineUpdateNodesOptsV2>;
export declare type DEngineInitPayload = {
    notes: NotePropsDict;
    schemas: SchemaModuleDict;
    wsRoot: string;
    vaults: DVault[];
    config: DendronConfig;
};
export declare type RenameNoteOpts = {
    oldLoc: DNoteLoc;
    newLoc: DNoteLoc;
};
export declare type RenderNoteOpts = {
    id: string;
};
export declare type ConfigWriteOpts = {
    config: DendronConfig;
};
export declare type DCommonProps = {
    notes: NotePropsDict;
    schemas: SchemaModuleDict;
    wsRoot: string;
    /**
     * NOTE: currently same as wsRoot. in the future, the two will be decoupled
     */
    configRoot: string;
    vaults: DVault[];
    links: DLink[];
    config: DendronConfig;
};
export declare type NoteChangeEntry = {
    note: NoteProps;
    status: "create" | "update" | "delete";
};
/**
 * Returns list of notes that were changed
 */
export declare type WriteNoteResp = Required<RespV2<NoteChangeEntry[]>>;
export declare type ConfigGetPayload = DendronConfig;
export declare type DCommonMethods = {
    bulkAddNotes: (opts: BulkAddNoteOpts) => Promise<Required<RespV2<NoteChangeEntry[]>>>;
    /**
     *
     * @param note
     * @param opts
     * @returns The updated note. If `newNode` is set, this will have the updated parent id
     */
    updateNote(note: NoteProps, opts?: EngineUpdateNodesOptsV2): Promise<NoteProps>;
    updateSchema: (schema: SchemaModuleProps) => Promise<void>;
    writeNote: (note: NoteProps, opts?: EngineWriteOptsV2) => Promise<WriteNoteResp>;
    writeSchema: (schema: SchemaModuleProps) => Promise<void>;
};
export declare type DEngineInitResp = RespV2<DEngineInitPayload>;
export declare type EngineDeleteNotePayload = NoteChangeEntry[];
export declare type DEngineDeleteSchemaPayload = DEngineInitPayload;
export declare type DEngineDeleteSchemaResp = DEngineInitResp;
export declare type EngineInfoResp = {
    version: string;
};
export declare type WorkspaceSettings = {
    folders: WorkspaceFolderRaw[];
    settings: any;
    extensions: WorkspaceExtensionSetting;
};
export declare type WorkspaceFolderRaw = {
    path: string;
    name?: string;
};
export declare type WorkspaceExtensionSetting = {
    recommendations: string[];
    unwantedRecommendations: string[];
};
export declare type EngineDeleteNoteResp = Required<RespV2<EngineDeleteNotePayload>>;
export declare type EngineQueryNoteResp = Required<RespV2<DNodeProps[]>>;
export declare type NoteQueryResp = Required<RespV2<NoteProps[]>>;
export declare type SchemaQueryResp = Required<RespV2<SchemaModuleProps[]>>;
export declare type StoreDeleteNoteResp = EngineDeleteNotePayload;
export declare type RenameNotePayload = NoteChangeEntry[];
export declare type RenderNotePayload = string | undefined;
export declare type GetNotePayload = {
    note: NoteProps | undefined;
    changed: NoteChangeEntry[];
};
export declare type QueryNotesOpts = {
    qs: string;
    vault?: DVault;
    createIfNew?: boolean;
};
export declare type DEngineInitSchemaResp = Required<RespV2<SchemaModuleProps[]>>;
export declare type DEngineSyncOpts = {
    metaOnly?: boolean;
};
export declare type BulkAddNoteOpts = {
    notes: NoteProps[];
};
export declare type DEngine = DCommonProps & DCommonMethods & {
    store: DStore;
    vaults: DVault[];
    hooks: DHookDict;
    init: () => Promise<DEngineInitResp>;
    deleteNote: (id: string, opts?: EngineDeleteOptsV2) => Promise<EngineDeleteNoteResp>;
    deleteSchema: (id: string, opts?: EngineDeleteOptsV2) => Promise<DEngineDeleteSchemaResp>;
    info: () => Promise<RespRequired<EngineInfoResp>>;
    sync: (opts?: DEngineSyncOpts) => Promise<DEngineInitResp>;
    getNoteByPath: (opts: GetNoteOptsV2) => Promise<RespV2<GetNotePayload>>;
    getSchema: (qs: string) => Promise<RespV2<SchemaModuleProps>>;
    querySchema: (qs: string) => Promise<SchemaQueryResp>;
    queryNotes: (opts: QueryNotesOpts) => Promise<NoteQueryResp>;
    queryNotesSync({ qs }: {
        qs: string;
        vault?: DVault;
    }): NoteQueryResp;
    renameNote: (opts: RenameNoteOpts) => Promise<RespV2<RenameNotePayload>>;
    renderNote: (opts: RenderNoteOpts) => Promise<RespV2<RenderNotePayload>>;
    writeConfig: (opts: ConfigWriteOpts) => Promise<RespV2<void>>;
    getConfig: () => Promise<RespV2<ConfigGetPayload>>;
};
/**
 * Implements the engine interface but has no backend store
 */
export declare type DEngineClient = Omit<DEngine, "store">;
export declare type DStore = DCommonProps & DCommonMethods & {
    init: () => Promise<DEngineInitResp>;
    deleteNote: (id: string, opts?: EngineDeleteOptsV2) => Promise<StoreDeleteNoteResp>;
    deleteSchema: (id: string, opts?: EngineDeleteOptsV2) => Promise<DEngineDeleteSchemaResp>;
    renameNote: (opts: RenameNoteOpts) => Promise<RenameNotePayload>;
};
export declare type DEngineV4 = {
    notes: NotePropsDict;
    schemas: SchemaModuleDict;
    wsRoot: string;
    vaults: DVault[];
    initialized: boolean;
} & DEngineV4Methods;
export declare type DEngineV4Methods = {
    init: () => Promise<DEngineInitResp>;
    deleteNote: (id: string, opts?: EngineDeleteOptsV2) => Promise<EngineDeleteNoteResp>;
    deleteSchema: (id: string, opts?: EngineDeleteOptsV2) => Promise<DEngineDeleteSchemaResp>;
    sync: (opts?: DEngineSyncOpts) => Promise<DEngineInitResp>;
    getNoteByPath: (opts: GetNoteOptsV2) => Promise<RespV2<GetNotePayload>>;
    getSchema: (qs: string) => Promise<RespV2<SchemaModuleProps>>;
    querySchema: (qs: string) => Promise<SchemaQueryResp>;
    queryNotes: (opts: QueryNotesOpts) => Promise<NoteQueryResp>;
    queryNotesSync({ qs }: {
        qs: string;
    }): NoteQueryResp;
    renameNote: (opts: RenameNoteOpts) => Promise<RespV2<RenameNotePayload>>;
    writeConfig: (opts: ConfigWriteOpts) => Promise<RespV2<void>>;
    getConfig: () => Promise<RespV2<ConfigGetPayload>>;
};
export declare type WorkspaceVault = {
    wsRoot: string;
    vault: DVault;
};
export declare type WorkspaceOpts = {
    wsRoot: string;
    vaults: DVault[];
};
/**
 * Used to specify exact location of a note
 */
export declare type GetNoteOpts = {
    fname: string;
} & WorkspaceVault;
export declare type DPod<TConfig> = {
    config: PodConfig[];
    execute(opts: BasePodExecuteOpts<TConfig>): Promise<any>;
};
export declare type PodConfig = {
    key: string;
    description: string;
    type: "string" | "number" | "boolean" | "object";
    required?: boolean;
    default?: any;
    example?: string;
};
export declare type BasePodExecuteOpts<TConfig> = {
    config: TConfig;
    engine: DEngineClient;
    wsRoot: string;
    vaults: DVault[];
};
export declare type DMessage<TType = string, TData = any, TSource = DMessageSource> = {
    type: TType;
    data: TData;
    source: TSource;
};
export declare enum DMessageSource {
    vscode = "vscode",
    webClient = "webClient"
}
export declare enum DMessageType {
    init = "init"
}
export declare enum TreeViewMessageType {
    "onSelect" = "onSelect",
    "onExpand" = "onExpand",
    "onGetActiveEditor" = "onGetActiveEditor",
    /**
     * View is ready
     */
    "onReady" = "onReady"
}
export declare enum GraphViewMessageType {
    "onSelect" = "onSelect",
    "onGetActiveEditor" = "onGetActiveEditor",
    "onReady" = "onReady"
}
export declare enum CalendarViewMessageType {
    "onSelect" = "onSelect",
    "onGetActiveEditor" = "onGetActiveEditor"
}
export declare enum ThemeMessageType {
    "onThemeChange" = "onThemeChange",
    "getTheme" = "getTheme"
}
export declare type OnDidChangeActiveTextEditorData = {
    note: NoteProps;
    sync?: boolean;
};
export declare type VSCodeMessage = DMessage;
export declare type OnDidChangeActiveTextEditorMsg = DMessage<"onDidChangeActiveTextEditor", OnDidChangeActiveTextEditorData>;
export declare type TreeViewMessage = DMessage<TreeViewMessageType, {
    id: string;
}>;
export declare type GraphViewMessage = DMessage<GraphViewMessageType, {
    id: string;
    vault?: string;
}>;
export declare type CalendarViewMessage = DMessage<CalendarViewMessageType, {
    id?: string;
    fname?: string;
}>;
export declare enum DendronWebViewKey {
    CONFIGURE = "dendron.configure",
    NOTE_GRAPH = "dendron.graph-note",
    SCHEMA_GRAPH = "dendron.graph-schema"
}
export declare enum DendronTreeViewKey {
    SAMPLE_VIEW = "dendron.sample",
    TREE_VIEW = "dendron.treeView",
    TREE_VIEW_V2 = "dendron.tree-view",
    BACKLINKS = "dendron.backlinks",
    CALENDAR_VIEW = "dendron.calendar-view"
}
