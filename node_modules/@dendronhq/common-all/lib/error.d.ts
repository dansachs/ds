import { ERROR_SEVERITY, ERROR_STATUS } from "./constants";
export declare type DendronErrorProps = {
    name: string;
    /**
     * General message
     */
    message: string;
    /**
     * Arbitrary payload
     */
    payload?: any;
    /**
     * See {@link ERROR_SEVERITY}
     */
    severity?: ERROR_SEVERITY;
    /**
     * Optional HTTP status code for error
     */
    code?: number;
    /**
     * Custom status errors
     */
    status?: string;
    /**
     * Raw Error object
     */
    error?: Error;
};
export declare type DendronErrorPlainObj = {
    isComposite: boolean;
} & DendronErrorProps;
export declare type IDendronError = DendronErrorPlainObj;
export declare class DendronError extends Error implements IDendronError {
    status?: string;
    payload?: string;
    severity?: ERROR_SEVERITY;
    code?: number;
    error?: Error;
    message: string;
    isComposite: boolean;
    static createPlainError(props: Omit<DendronErrorProps, "name">): DendronErrorPlainObj;
    static createFromStatus({ status, ...rest }: {
        status: ERROR_STATUS;
    } & Partial<DendronErrorProps>): DendronError;
    constructor({ message, status, payload, severity, code, error, }: Omit<DendronErrorProps, "name">);
}
export declare class DendronCompositeError extends Error implements IDendronError {
    payload: DendronErrorPlainObj[];
    message: string;
    isComposite: boolean;
    constructor(errors: IDendronError[]);
}
export declare class IllegalOperationError extends DendronError {
}
export declare function stringifyError(err: Error): string;
export declare const error2PlainObject: (err: IDendronError) => DendronErrorPlainObj;
/** Statically ensure that a code path is unreachable using a variable that has been exhaustively used.
 *
 * The use case for this function is that when using a switch or a chain of if/else if statements,
 * this function allows you to ensure that after all possibilities have been already checked, no further
 * possibilities remain. Importantly, this is done statically (i.e. during compilation), so if anyone
 * revises the code in a way that adds expands the possibilities, a compiler error will warn them that
 * they must revise this part of the code as well.
 *
 * An example of how this function may be used is below:
 *
 *     type Names = "bar" | "baz";
 *
 *     function foo(name: Names) {
 *       if (name === "bar") { ... }
 *       else if (name === "baz") { ... }
 *       else assertUnreachable(name);
 *     }
 *
 * Let's say someone changes the type Names to `type Names = "bar" | "baz" | "ham";`. Thanks to this
 * assertion, the compiler will warn them that this branch is now reachable, and something is wrong.
 *
 * @param x
 */
export declare function assertUnreachable(_never?: never): never;
