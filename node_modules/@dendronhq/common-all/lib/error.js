"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertUnreachable = exports.error2PlainObject = exports.stringifyError = exports.IllegalOperationError = exports.DendronCompositeError = exports.DendronError = void 0;
class DendronError extends Error {
    constructor({ message, status, payload, severity, code, error, }) {
        super(message);
        this.isComposite = false;
        this.status = status || "unknown";
        this.severity = severity;
        this.message = message || "";
        if ((payload === null || payload === void 0 ? void 0 : payload.message) && (payload === null || payload === void 0 ? void 0 : payload.stack)) {
            this.payload = JSON.stringify({
                msg: payload.message,
                stack: payload.stack,
            });
        }
        else {
            this.payload = JSON.stringify(payload || {});
        }
        this.code = code;
        this.error = error;
    }
    static createPlainError(props) {
        return exports.error2PlainObject({
            ...props,
            isComposite: false,
            name: "DendronError",
        });
    }
    static createFromStatus({ status, ...rest }) {
        return new DendronError({
            name: "DendronError",
            message: status,
            status,
            ...rest,
        });
    }
}
exports.DendronError = DendronError;
class DendronCompositeError extends Error {
    constructor(errors) {
        super("multiple errors");
        this.isComposite = true;
        this.payload = errors.map((err) => exports.error2PlainObject(err));
        this.message = "multiple errors";
    }
}
exports.DendronCompositeError = DendronCompositeError;
class IllegalOperationError extends DendronError {
}
exports.IllegalOperationError = IllegalOperationError;
function stringifyError(err) {
    return JSON.stringify(err, Object.getOwnPropertyNames(err));
}
exports.stringifyError = stringifyError;
const error2PlainObject = (err) => {
    const out = {};
    Object.getOwnPropertyNames(err).forEach((k) => {
        // @ts-ignore
        out[k] = err[k];
    });
    return out;
};
exports.error2PlainObject = error2PlainObject;
/** Statically ensure that a code path is unreachable using a variable that has been exhaustively used.
 *
 * The use case for this function is that when using a switch or a chain of if/else if statements,
 * this function allows you to ensure that after all possibilities have been already checked, no further
 * possibilities remain. Importantly, this is done statically (i.e. during compilation), so if anyone
 * revises the code in a way that adds expands the possibilities, a compiler error will warn them that
 * they must revise this part of the code as well.
 *
 * An example of how this function may be used is below:
 *
 *     type Names = "bar" | "baz";
 *
 *     function foo(name: Names) {
 *       if (name === "bar") { ... }
 *       else if (name === "baz") { ... }
 *       else assertUnreachable(name);
 *     }
 *
 * Let's say someone changes the type Names to `type Names = "bar" | "baz" | "ham";`. Thanks to this
 * assertion, the compiler will warn them that this branch is now reachable, and something is wrong.
 *
 * @param x
 */
function assertUnreachable(_never) {
    throw new DendronError({
        message: "This error should never occur! Please report a bug if you have encountered this.",
    });
}
exports.assertUnreachable = assertUnreachable;
//# sourceMappingURL=error.js.map