"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isNotUndefined = exports.isBlockAnchor = exports.isNumeric = exports.getSlugger = exports.DUtils = void 0;
const minimatch_1 = __importDefault(require("minimatch"));
const semver_1 = __importDefault(require("semver"));
const github_slugger_1 = __importDefault(require("github-slugger"));
const querystring_1 = __importDefault(require("querystring"));
const lodash_1 = __importDefault(require("lodash"));
class DUtils {
}
exports.DUtils = DUtils;
DUtils.minimatch = minimatch_1.default;
DUtils.semver = semver_1.default;
DUtils.querystring = querystring_1.default;
const getSlugger = () => {
    return new github_slugger_1.default();
};
exports.getSlugger = getSlugger;
/**
 * determine if given parameter is numeric
 * https://stackoverflow.com/questions/18082/validate-decimal-numbers-in-javascript-isnumeric/1830844#1830844
 * @param n
 * @returns boolean
 */
const isNumeric = (n) => {
    return !isNaN(parseInt(n)) && isFinite(n);
};
exports.isNumeric = isNumeric;
function isBlockAnchor(anchor) {
    // not undefined, not an empty string, and the first character is ^
    return !!anchor && anchor[0] === "^";
}
exports.isBlockAnchor = isBlockAnchor;
/** A type guard for things that are not undefined.
 *
 * This is equivalent to !_.isUndefined(), except that it provides a type guard
 * ensuring the parameter is not undefined. This is useful when filtering:
 *
 * function foo(list: (string | undefined)[]) {
 *   const stringsOnly = list.filter(isNotUndefined);
 * }
 *
 * This will give stringsOnly the type string[]. Without the type guard, it would have
 * received the type (string | undefined)[] despite the fact that we filtered out undefined.
 */
function isNotUndefined(t) {
    return !lodash_1.default.isUndefined(t);
}
exports.isNotUndefined = isNotUndefined;
//# sourceMappingURL=utils.js.map