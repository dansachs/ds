import { URI } from "vscode-uri";
import { DendronError } from "./error";
import { DEngineClient, DLink, DNodeOpts, DNodePropsDict, DNodePropsQuickInputV2, DNodeProps, DNoteLoc, DVault, NoteOpts, NotePropsDict, NoteProps, SchemaModuleDict, SchemaModuleOpts, SchemaModuleProps, SchemaOpts, SchemaPropsDict, SchemaProps, SchemaRaw, SchemaTemplate } from "./types";
/**
 * Utilities for dealing with nodes
 */
export declare class DNodeUtils {
    static addChild(parent: DNodeProps, child: DNodeProps): void;
    static create(opts: DNodeOpts): DNodeProps;
    static basename(nodePath: string, rmExtension?: boolean): string;
    static dirName(nodePath: string): string;
    static domainName(nodePath: string): string;
    static fname(nodePath: string): string;
    static enhancePropForQuickInput({ props, schemas, vaults, wsRoot, }: {
        props: DNodeProps;
        schemas: SchemaModuleDict;
        vaults: DVault[];
        wsRoot: string;
    }): DNodePropsQuickInputV2;
    static enhancePropForQuickInputV3(opts: {
        props: DNodeProps;
        schemas: SchemaModuleDict;
        vaults: DVault[];
        wsRoot: string;
        alwaysShow?: boolean;
    }): DNodePropsQuickInputV2;
    static findClosestParent(fpath: string, nodes: DNodeProps[], opts: {
        noStubs?: boolean;
        vault: DVault;
        wsRoot: string;
    }): DNodeProps;
    static getCustomProps(props: any): any;
    static getDepth(node: DNodeProps): number;
    static getDomain(node: DNodeProps, opts: {
        nodeDict: DNodePropsDict;
    }): DNodeProps;
    static getFullPath(opts: {
        wsRoot: string;
        vault: DVault;
        basename: string;
    }): string;
    static getParent(node: DNodeProps, opts: {
        nodeDict: DNodePropsDict;
    }): DNodeProps;
    static getChildren(node: DNodeProps, opts: {
        recursive?: boolean;
        nodeDict: DNodePropsDict;
    }): DNodeProps[];
    static isRoot(note: DNodeProps): boolean;
    /**
     * Given a note, return the leaf name
     * @param note DNodeProps
     * @returns name of leaf node
     */
    static getLeafName(note: DNodeProps): string | undefined;
}
export declare class NoteUtils {
    static RE_FM: RegExp;
    static RE_FM_UPDATED: RegExp;
    static RE_FM_CREATED: RegExp;
    static addBacklink({ from, to, link, }: {
        from: NoteProps;
        to: NoteProps;
        link: DLink;
    }): void;
    /**
     * Add node to parent
     * Create stubs if no direct parent exists
     * @param opts
     * @returns All notes that were changed including the parent
     */
    static addParent(opts: {
        note: NoteProps;
        notesList: NoteProps[];
        createStubs: boolean;
        wsRoot: string;
    }): NoteProps[];
    static addSchema(opts: {
        note: NoteProps;
        schemaModule: SchemaModuleProps;
        schema: SchemaProps;
    }): void;
    static create(opts: NoteOpts): NoteProps;
    static createWithSchema({ noteOpts, engine, }: {
        noteOpts: NoteOpts;
        engine: DEngineClient;
    }): NoteProps;
    static createRoot(opts: Partial<NoteOpts> & {
        vault: DVault;
    }): NoteProps;
    /**
     * Create stubs and add notes to parent
     * @param from
     * @param to
     */
    static createStubs(from: NoteProps, to: NoteProps): NoteProps[];
    /**
     * Create a wiki link to the given note
     *
     * @returns
     */
    static createWikiLink(opts: {
        note: NoteProps;
        anchor?: {
            value: string;
            type: "header" | "blockAnchor";
        };
        useVaultPrefix?: boolean;
        useTitle?: boolean;
    }): string;
    static fromSchema({ fname, schemaModule, schemaId, vault, }: {
        fname: string;
        schemaModule: SchemaModuleProps;
        schemaId: string;
        vault: DVault;
    }): NoteProps;
    static genSchemaDesc(note: NoteProps, schemaMod?: SchemaModuleProps): string;
    static genJournalNoteTitle(opts: {
        fname: string;
        journalName: string;
    }): string;
    static genTitle(fname: string): string;
    static getNotesByFname({ fname, notes, vault, }: {
        fname: string;
        notes: NotePropsDict | NoteProps[];
        vault?: DVault;
    }): NoteProps[];
    static getNoteByFnameV5({ fname, notes, vault, wsRoot, }: {
        fname: string;
        notes: NotePropsDict | NoteProps[];
        vault: DVault;
        wsRoot: string;
    }): NoteProps | undefined;
    static getNoteOrThrow({ fname, notes, vault, wsRoot, }: {
        fname: string;
        notes: NotePropsDict | NoteProps[];
        vault: DVault;
        wsRoot: string;
    }): NoteProps;
    /**
     @deprecated
     */
    static getNoteByFname(fname: string, notes: NotePropsDict, opts?: {
        throwIfEmpty?: boolean;
        vault?: DVault;
    }): NoteProps | undefined;
    static getNotesWithLinkTo({ note, notes, }: {
        note: NoteProps;
        notes: NotePropsDict;
    }): NoteProps[];
    static getFullPath({ note, wsRoot, }: {
        note: NoteProps;
        wsRoot: string;
    }): string;
    static getURI({ note, wsRoot }: {
        note: NoteProps;
        wsRoot: string;
    }): URI;
    static getPathUpTo(hpath: string, numCompoenents: number): string;
    static getRoots(notes: NotePropsDict): NoteProps[];
    /**
     * Add props from @param noteHydrated to @param noteRaw
     * @param param0
     * @returns
     */
    static hydrate({ noteRaw, noteHydrated, }: {
        noteRaw: NoteProps;
        noteHydrated: NoteProps;
    }): {
        parent: string | null;
        children: string[];
        id: string;
        title: string;
        desc: string;
        links: DLink[];
        anchors: {
            [index: string]: import("./types").DNoteAnchorPositioned | undefined;
        };
        fname: string;
        type: import("./types").DNodeType;
        updated: number;
        created: number;
        stub?: boolean | undefined;
        schemaStub?: boolean | undefined;
        data: any;
        body: string;
        custom?: any;
        schema?: {
            moduleId: string;
            schemaId: string;
        } | undefined;
        vault: DVault;
    };
    static match({ notePath, pattern }: {
        notePath: string;
        pattern: string;
    }): boolean;
    static isDefaultTitle(props: NoteProps): boolean;
    static normalizeFname(nodePath: string): string;
    static serializeMeta(props: NoteProps): any;
    static serialize(props: NoteProps, opts?: {
        writeHierarchy?: boolean;
    }): string;
    static toLogObj(note: NoteProps): {
        fname: string;
        id: string;
        children: string[];
        vault: DVault;
        parent: string | null;
    };
    static toNoteLoc(note: NoteProps): DNoteLoc;
    static uri2Fname(uri: URI): string;
    static validate(noteProps: Partial<NoteProps>): true | DendronError;
}
declare type SchemaMatchResult = {
    schemaModule: SchemaModuleProps;
    schema: SchemaProps;
    namespace: boolean;
    notePath: string;
};
export declare class SchemaUtils {
    static applyTemplate(opts: {
        template: SchemaTemplate;
        note: NoteProps;
        engine: DEngineClient;
    }): boolean;
    static create(opts: (SchemaOpts | SchemaRaw) & {
        vault: DVault;
    }): SchemaProps;
    static createModule(opts: SchemaModuleOpts): SchemaModuleOpts;
    static createModuleProps(opts: {
        fname: string;
        vault: DVault;
    }): SchemaModuleProps;
    static createRootModule(opts: Partial<SchemaProps> & {
        vault: DVault;
    }): SchemaModuleOpts;
    static createRootModuleProps(fname: string, vault: DVault, opts?: Partial<SchemaProps>): SchemaModuleProps;
    static enhanceForQuickInput({ props, vaults, }: {
        props: SchemaModuleProps;
        vaults: DVault[];
    }): DNodePropsQuickInputV2;
    static getModuleRoot(module: SchemaModuleOpts | SchemaModuleProps): SchemaProps;
    /**
     * If no pattern field, get the id.
     * If pattern field, check if namespace and translate into glob pattern
     * @param schema
     * @param opts
     * @returns
     */
    static getPattern: (schema: SchemaProps, opts?: {
        isNotNamespace?: boolean | undefined;
    } | undefined) => string;
    /**
     * Get full pattern starting from the root
     * @param schema
     * @param schemas
     * @returns
     */
    static getPatternRecursive: (schema: SchemaProps, schemas: SchemaPropsDict) => string;
    /**
     * @param param0
     * @returns
     */
    static getPath({ root, fname }: {
        root: string;
        fname: string;
    }): string;
    /**
     @deprecated
     */
    static getSchemaModuleByFnameV4({ fname, schemas, wsRoot, vault, }: {
        fname: string;
        schemas: SchemaModuleDict | SchemaModuleProps[];
        wsRoot: string;
        vault: DVault;
    }): SchemaModuleProps | undefined;
    static getSchemaFromNote({ note, engine, }: {
        note: NoteProps;
        engine: DEngineClient;
    }): SchemaModuleProps | undefined;
    static hasSimplePattern: (schema: SchemaProps, opts?: {
        isNotNamespace?: boolean | undefined;
    } | undefined) => boolean;
    /**
     * Matcn and assign schemas to all nodes within
     * a domain
     *
     * @param domain
     * @param notes
     * @param schemas
     */
    static matchDomain(domain: NoteProps, notes: NotePropsDict, schemas: SchemaModuleDict): void;
    static matchDomainWithSchema(opts: {
        noteCandidates: NoteProps[];
        notes: NotePropsDict;
        schemaCandidates: SchemaProps[];
        schemaModule: SchemaModuleProps;
        matchNamespace?: boolean;
    }): void;
    static matchPath(opts: {
        notePath: string;
        schemaModDict: SchemaModuleDict;
    }): SchemaMatchResult | undefined;
    /**
     *
     * @param param0
     * @return
     *  - schemaModule
     *  - schema
     *  - namespace
     *  - notePath
     */
    static matchPathWithSchema({ notePath, matched, schemaCandidates, schemaModule, matchNamespace, }: {
        notePath: string;
        matched: string;
        schemaCandidates: SchemaProps[];
        schemaModule: SchemaModuleProps;
        matchNamespace?: boolean;
    }): SchemaMatchResult | undefined;
    static matchNotePathWithSchemaAtLevel({ notePath, schemas, schemaModule, matchNamespace, }: {
        notePath: string;
        schemas: SchemaProps[];
        schemaModule: SchemaModuleProps;
        matchNamespace?: boolean;
    }): SchemaMatchResult | undefined;
    static serializeSchemaProps(props: SchemaProps | SchemaOpts): SchemaRaw;
    static serializeModuleProps(moduleProps: SchemaModuleProps): string;
    static serializeModuleOpts(moduleOpts: SchemaModuleOpts): string;
}
export {};
