"use strict";

class CanceledError extends Error {
  constructor() {
    super('throttled invocation was canceled');
    this.name = 'CanceledError';
  }

}

class Delay {
  constructor(lastInvocationDone, wait) {
    this.effect = new Promise((resolve, reject) => {
      this.timeout = setTimeout(resolve, wait);
      this.resolve = resolve;
      this.reject = reject;
    });
    this.effect.catch(() => {});
    this.ready = lastInvocationDone.then(() => this.effect);
  }

  flush() {
    clearTimeout(this.timeout);
    this.resolve();
  }

  cancel() {
    clearTimeout(this.timeout);
    this.reject(new CanceledError());
  }

}

function throttle(fn, _wait, options = {}) {
  const wait = _wait != null && Number.isFinite(_wait) ? Math.max(_wait, 0) : 0;

  const getNextArgs = options.getNextArgs || ((prev, next) => next);

  let nextArgs;
  let lastInvocationDone = Promise.resolve();
  let delay = new Delay(lastInvocationDone, 0);
  let nextInvocation = null;

  function invoke() {
    const args = nextArgs; // istanbul ignore next

    if (!args) throw new Error('unexpected error: nextArgs is null');
    nextInvocation = null;
    nextArgs = null;
    let result;

    try {
      result = Promise.resolve(fn(...args));
    } catch (error) {
      result = Promise.reject(error);
    }

    lastInvocationDone = result.catch(() => {});
    delay = new Delay(lastInvocationDone, wait);
    return result;
  }

  function wrapper(...args) {
    nextArgs = nextArgs ? getNextArgs(nextArgs, args) : args;
    if (!nextArgs) throw new Error('unexpected error: nextArgs is null');
    if (!nextInvocation) nextInvocation = delay.ready.then(invoke);
    return nextInvocation;
  }

  wrapper.cancel = async () => {
    const _lastInvocationDone = lastInvocationDone;
    delay.cancel();
    nextInvocation = null;
    nextArgs = null;
    lastInvocationDone = Promise.resolve();
    delay = new Delay(lastInvocationDone, 0);
    await _lastInvocationDone;
  };

  wrapper.flush = async () => {
    delay.flush();
    await lastInvocationDone;
  };

  return wrapper;
}

;
throttle.CanceledError = CanceledError;
module.exports = throttle;