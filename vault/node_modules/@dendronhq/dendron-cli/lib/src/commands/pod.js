"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PodSource = exports.executePod = exports.enrichPodArgs = exports.setupPodArgs = exports.fetchPodClassV4 = void 0;
const common_all_1 = require("@dendronhq/common-all");
const pods_core_1 = require("@dendronhq/pods-core");
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const utils_1 = require("./utils");
function fetchPodClassV4(podId, opts) {
    const { podSource, pods } = opts;
    if (podSource === PodSource.BUILTIN) {
        if (!pods) {
            throw Error("pods needs to be defined");
        }
        const podClass = lodash_1.default.find(pods, {
            id: podId,
        });
        if (lodash_1.default.isUndefined(podClass)) {
            throw Error("no pod found");
        }
        return podClass;
    }
    else {
        if (!opts.podPkg || !opts.wsRoot) {
            throw Error("podPkg not defined");
        }
        const podEntries = require(`${path_1.default.join(opts.wsRoot, "node_modules", opts.podPkg)}`).pods;
        const podClass = lodash_1.default.find(podEntries, (entry) => {
            return entry.id === podId && entry.kind === opts.podType;
        });
        if (!podClass) {
            throw Error("no podClass found");
        }
        return podClass;
    }
}
exports.fetchPodClassV4 = fetchPodClassV4;
function setupPodArgs(args) {
    args.option("podId", {
        describe: "id of pod to use",
        requiresArg: true,
    });
    args.option("showConfig", {
        describe: "show pod configuration",
    });
    args.option("genConfig", {
        describe: "show pod configuration",
    });
    args.option("podPkg", {
        describe: "if specifying a custom pod, name of pkg",
    });
    args.option("config", {
        describe: "pass in config instead of reading from file. format is comma delimited {key}={value} pairs",
    });
    args.option("podSource", {
        describe: "podSource",
        choices: lodash_1.default.values(PodSource),
        default: PodSource.BUILTIN,
    });
}
exports.setupPodArgs = setupPodArgs;
const enrichPodArgs = (opts) => {
    const { pods, podType } = opts;
    const enrichFunc = async (args) => {
        const { podId, showConfig, podSource, podPkg, genConfig, config } = args;
        const engineArgs = await utils_1.setupEngine(args);
        // normalized wsRoot
        const wsRoot = engineArgs.wsRoot;
        const podClass = fetchPodClassV4(podId, {
            pods,
            podType,
            podSource,
            podPkg,
            wsRoot,
        });
        if (showConfig) {
            const config = new podClass().config;
            console.log(config);
            process.exit(0);
        }
        if (genConfig) {
            const podsDir = pods_core_1.PodUtils.getPodDir({ wsRoot });
            const configPath = pods_core_1.PodUtils.genConfigFile({
                podsDir,
                podClass,
                force: true,
            });
            console.log(`config generated at ${configPath}`);
            process.exit(0);
        }
        const podsDir = path_1.default.join(wsRoot, "pods");
        let cleanConfig;
        if (config) {
            cleanConfig = {};
            config.split(",").map((ent) => {
                const [k, v] = ent.split("=");
                cleanConfig[k] = v;
            });
        }
        else {
            cleanConfig = pods_core_1.PodUtils.getConfig({ podsDir, podClass });
            if (!cleanConfig) {
                const podConfigPath = pods_core_1.PodUtils.getConfigPath({ podsDir, podClass });
                throw new common_all_1.DendronError({
                    status: "no-config",
                    message: `no config found. please create a config at ${podConfigPath}`,
                });
            }
        }
        return { ...args, ...engineArgs, podClass, config: cleanConfig };
    };
    return enrichFunc;
};
exports.enrichPodArgs = enrichPodArgs;
const executePod = async (opts) => {
    const { podClass: PodClass, config, wsRoot, engine, server } = opts;
    const vaults = engine.vaults;
    const pod = new PodClass();
    console.log("running pod...");
    await pod.execute({ wsRoot, config, engine, vaults });
    server.close((err) => {
        if (err) {
            throw err;
        }
    });
    console.log("done");
};
exports.executePod = executePod;
var PodSource;
(function (PodSource) {
    PodSource["CUSTOM"] = "custom";
    PodSource["BUILTIN"] = "builtin";
})(PodSource = exports.PodSource || (exports.PodSource = {}));
//# sourceMappingURL=pod.js.map