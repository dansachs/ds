"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DoctorCLICommand = exports.DoctorActions = void 0;
const common_all_1 = require("@dendronhq/common-all");
const engine_server_1 = require("@dendronhq/engine-server");
// @ts-ignore
const async_throttle_1 = __importDefault(require("@jcoreio/async-throttle"));
const lodash_1 = __importDefault(require("lodash"));
const base_1 = require("./base");
const utils_1 = require("./utils");
var DoctorActions;
(function (DoctorActions) {
    DoctorActions["FIX_FRONTMATTER"] = "fixFrontmatter";
    DoctorActions["H1_TO_TITLE"] = "h1ToTitle";
    DoctorActions["HI_TO_H2"] = "h1ToH2";
    DoctorActions["REMOVE_STUBS"] = "removeStubs";
    DoctorActions["OLD_NOTE_REF_TO_NEW"] = "oldNoteRefToNew";
    DoctorActions["CREATE_MISSING_LINKED_NOTES"] = "createMissingLinkedNotes";
})(DoctorActions = exports.DoctorActions || (exports.DoctorActions = {}));
class DoctorCLICommand extends base_1.CLICommand {
    constructor() {
        super({ name: "doctor", desc: "doctor helps you fix your notes" });
    }
    buildArgs(args) {
        super.buildArgs(args);
        utils_1.setupEngineArgs(args);
        args.option("action", {
            describe: "what action the doctor should take",
            type: "string",
            requiresArg: true,
            choices: Object.values(DoctorActions),
            // default: DoctorActions.FIX_FM
        });
        args.option("query", {
            describe: "run doctor over a query",
            type: "string",
        });
        args.option("limit", {
            describe: "limit num changes",
            type: "number",
        });
        args.option("dryRun", {
            describe: "dry run",
            type: "boolean",
        });
    }
    getWildLinkDestinations(notes, engine) {
        const { wsRoot, vaults } = engine;
        let wildWikiLinks = [];
        lodash_1.default.forEach(notes, (note) => {
            const links = note.links;
            if (lodash_1.default.isEmpty(links)) {
                return;
            }
            wildWikiLinks = wildWikiLinks.concat(lodash_1.default.filter(links, (link) => {
                var _a;
                if (link.type !== "wiki") {
                    return false;
                }
                const destVault = ((_a = link.to) === null || _a === void 0 ? void 0 : _a.vaultName)
                    ? common_all_1.VaultUtils.getVaultByName({ vaults, vname: link.to.vaultName })
                    : note.vault;
                const noteExists = common_all_1.NoteUtils.getNoteByFnameV5({
                    fname: link.to.fname,
                    vault: destVault,
                    notes: notes,
                    wsRoot: wsRoot,
                });
                return !noteExists;
            }));
            return true;
        });
        const uniqueCandidates = lodash_1.default.map(lodash_1.default.uniqBy(wildWikiLinks, "to.fname"), (link) => {
            var _a;
            const destVault = ((_a = link.to) === null || _a === void 0 ? void 0 : _a.vaultName)
                ? common_all_1.VaultUtils.getVaultByName({ vaults, vname: link.to.vaultName })
                : common_all_1.VaultUtils.getVaultByName({ vaults, vname: link.from.vaultName });
            return common_all_1.NoteUtils.create({
                fname: link.to.fname,
                vault: destVault,
            });
        });
        return uniqueCandidates;
    }
    async enrichArgs(args) {
        const engineArgs = await utils_1.setupEngine(args);
        return { ...args, ...engineArgs };
    }
    async execute(opts) {
        const { action, engine, query, candidates, limit, dryRun, exit } = lodash_1.default.defaults(opts, {
            limit: 99999,
            exit: true,
        });
        let notes;
        if (lodash_1.default.isUndefined(candidates)) {
            notes = query
                ? engine.queryNotesSync({ qs: query }).data
                : lodash_1.default.values(engine.notes);
        }
        else {
            console.log(`${candidates.length} candidate(s) were passed`);
            notes = candidates;
        }
        notes = notes.filter((n) => !n.stub);
        this.L.info({ msg: "prep doctor", numResults: notes.length });
        let numChanges = 0;
        let engineWrite = dryRun
            ? () => { }
            : async_throttle_1.default(lodash_1.default.bind(engine.writeNote, engine), 300, {
                leading: true,
            });
        let engineDelete = dryRun
            ? () => { }
            : async_throttle_1.default(lodash_1.default.bind(engine.deleteNote, engine), 300, {
                leading: true,
            });
        let engineGetNoteByPath = dryRun
            ? () => { }
            : async_throttle_1.default(lodash_1.default.bind(engine.getNoteByPath, engine), 300, {
                leading: true,
            });
        let doctorAction;
        switch (action) {
            case DoctorActions.FIX_FRONTMATTER: {
                console.log("the CLI currently doesn't support this action. please run this using the plugin");
                process.exit();
            }
            case DoctorActions.H1_TO_TITLE: {
                doctorAction = async (note) => {
                    let changes = [];
                    const proc = engine_server_1.MDUtilsV4.procFull({
                        dest: engine_server_1.DendronASTDest.MD_DENDRON,
                        engine,
                        fname: note.fname,
                        vault: note.vault,
                    });
                    const newBody = await proc()
                        .use(engine_server_1.RemarkUtils.h1ToTitle(note, changes))
                        .process(note.body);
                    note.body = newBody.toString();
                    if (!lodash_1.default.isEmpty(changes)) {
                        await engineWrite(note, { updateExisting: true });
                        this.L.info({ msg: `changes ${note.fname}`, changes });
                        numChanges += 1;
                        return;
                    }
                    else {
                        return;
                    }
                };
                break;
            }
            case DoctorActions.HI_TO_H2: {
                doctorAction = async (note) => {
                    let changes = [];
                    const proc = engine_server_1.MDUtilsV4.procFull({
                        dest: engine_server_1.DendronASTDest.MD_DENDRON,
                        engine,
                        fname: note.fname,
                        vault: note.vault,
                    });
                    const newBody = await proc()
                        .use(engine_server_1.RemarkUtils.h1ToH2(note, changes))
                        .process(note.body);
                    note.body = newBody.toString();
                    if (!lodash_1.default.isEmpty(changes)) {
                        await engineWrite(note, { updateExisting: true });
                        this.L.info({ msg: `changes ${note.fname}`, changes });
                        numChanges += 1;
                        return;
                    }
                    else {
                        return;
                    }
                };
                break;
            }
            case DoctorActions.REMOVE_STUBS: {
                doctorAction = async (note) => {
                    let changes = [];
                    if (lodash_1.default.trim(note.body) === "") {
                        changes.push({
                            status: "delete",
                            note,
                        });
                    }
                    if (!lodash_1.default.isEmpty(changes)) {
                        await engineDelete(note);
                        const vname = common_all_1.VaultUtils.getName(note.vault);
                        this.L.info(`doctor ${DoctorActions.REMOVE_STUBS} ${note.fname} ${vname}`);
                        numChanges += 1;
                        return;
                    }
                    else {
                        return;
                    }
                };
                break;
            }
            case DoctorActions.OLD_NOTE_REF_TO_NEW: {
                doctorAction = async (note) => {
                    let changes = [];
                    const proc = engine_server_1.MDUtilsV4.procFull({
                        dest: engine_server_1.DendronASTDest.MD_DENDRON,
                        engine,
                        fname: note.fname,
                        vault: note.vault,
                    });
                    const newBody = await proc()
                        .use(engine_server_1.RemarkUtils.oldNoteRef2NewNoteRef(note, changes))
                        .process(note.body);
                    note.body = newBody.toString();
                    if (!lodash_1.default.isEmpty(changes)) {
                        await engineWrite(note, { updateExisting: true });
                        this.L.info({ msg: `changes ${note.fname}`, changes });
                        numChanges += 1;
                        return;
                    }
                    else {
                        return;
                    }
                };
                break;
            }
            case DoctorActions.CREATE_MISSING_LINKED_NOTES: {
                // this action is disabled for workspace scope for now.
                if (lodash_1.default.isUndefined(candidates)) {
                    console.log(`doctor ${DoctorActions.CREATE_MISSING_LINKED_NOTES} requires explicitly passing one candidate note.`);
                    return;
                }
                notes = this.getWildLinkDestinations(notes, engine);
                doctorAction = async (note) => {
                    const vname = common_all_1.VaultUtils.getName(note.vault);
                    await engineGetNoteByPath({
                        npath: note.fname,
                        createIfNew: true,
                        vault: note.vault,
                    });
                    console.log(`doctor ${DoctorActions.CREATE_MISSING_LINKED_NOTES} ${note.fname} ${vname}`);
                    numChanges += 1;
                };
                break;
            }
        }
        await lodash_1.default.reduce(notes, async (accInner, note) => {
            await accInner;
            if (numChanges >= limit) {
                return;
            }
            this.L.debug({ msg: `processing ${note.fname}` });
            return doctorAction(note);
        }, Promise.resolve());
        console.log(`doctor fixed ${numChanges} notes`);
        this.L.info({ msg: "doctor done", numChanges });
        if (exit) {
            process.exit();
        }
        return;
    }
}
exports.DoctorCLICommand = DoctorCLICommand;
//# sourceMappingURL=doctor.js.map