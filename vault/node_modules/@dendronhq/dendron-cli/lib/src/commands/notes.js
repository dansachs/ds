"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NoteCLICommand = exports.NoteCommands = void 0;
const common_all_1 = require("@dendronhq/common-all");
const lodash_1 = __importDefault(require("lodash"));
const base_1 = require("./base");
const utils_1 = require("./utils");
var NoteCommands;
(function (NoteCommands) {
    NoteCommands["LOOKUP"] = "lookup";
    NoteCommands["DELETE"] = "delete";
})(NoteCommands = exports.NoteCommands || (exports.NoteCommands = {}));
function checkQueryAndVault(opts) {
    const vaults = opts.engine.vaults;
    let vault;
    if (!opts.query) {
        throw Error("no query found");
    }
    if (lodash_1.default.size(opts.engine.vaults) > 1 && !opts.vault) {
        throw Error("need to specify vault");
    }
    else {
        vault = opts.vault
            ? common_all_1.VaultUtils.getVaultByNameOrThrow({ vaults, vname: opts.vault })
            : vaults[0];
    }
    return { query: opts.query, vault };
}
class NoteCLICommand extends base_1.CLICommand {
    constructor() {
        super({ name: "note <cmd>", desc: "note related commands" });
    }
    buildArgs(args) {
        super.buildArgs(args);
        utils_1.setupEngineArgs(args);
        args.positional("cmd", {
            describe: "a command to run",
            choices: Object.values(NoteCommands),
            type: "string",
        });
        args.option("query", {
            describe: "the query to run",
            type: "string",
        });
    }
    async enrichArgs(args) {
        const engineArgs = await utils_1.setupEngine(args);
        return { ...args, ...engineArgs };
    }
    async execute(opts) {
        const { cmd, engine, wsRoot } = opts;
        try {
            switch (cmd) {
                case NoteCommands.LOOKUP: {
                    const { query, vault } = checkQueryAndVault(opts);
                    const { data } = await engine.getNoteByPath({
                        npath: query,
                        createIfNew: true,
                        vault,
                    });
                    this.print(JSON.stringify(data, null, 4));
                    return data;
                }
                case NoteCommands.DELETE: {
                    const { query, vault } = checkQueryAndVault(opts);
                    const note = common_all_1.NoteUtils.getNoteOrThrow({
                        fname: query,
                        notes: engine.notes,
                        vault,
                        wsRoot,
                    });
                    const resp = await engine.deleteNote(note.id);
                    this.print(`deleted ${note.fname}`);
                    return resp;
                }
                default: {
                    throw Error("bad option");
                }
            }
        }
        finally {
            if (opts.server.close) {
                opts.server.close();
            }
        }
    }
}
exports.NoteCLICommand = NoteCLICommand;
//# sourceMappingURL=notes.js.map