"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AirtableExportPod = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const lodash_1 = __importDefault(require("lodash"));
const basev3_1 = require("../basev3");
const common_all_1 = require("@dendronhq/common-all");
const path_1 = __importDefault(require("path"));
const limiter_1 = require("limiter");
const axios_1 = __importDefault(require("axios"));
const ID = "dendron.airtable";
// Allow 5 req/sec. Also understands 'hour', 'minute', 'day', or a no. of ms
// @ts-ignore
const limiter = new limiter_1.RateLimiter({ tokensPerInterval: 5, interval: "second" });
class AirtableExportPod extends basev3_1.ExportPod {
    get config() {
        return super.config.concat([
            {
                key: "tableName",
                description: "Name of the airtable",
                type: "string",
                required: true,
            },
            {
                key: "srcHierarchy",
                description: "The src .md file from where to start the sync",
                type: "string",
                required: true,
            },
            {
                key: "apiKey",
                description: "Api key for airtable",
                type: "string",
                required: true,
            },
            {
                key: "baseId",
                description: " base Id of airtable base",
                type: "string",
                required: true,
            },
            {
                key: "srcFieldMapping",
                description: "mapping of airtable fields with the note eg: {Created On: created, Notes: body}",
                type: "object",
                required: true,
            },
        ]);
    }
    //filters the note's property as per srcFieldMapping provided
    notesToSrcFieldMap(notes, srcFieldMapping) {
        const data = notes.map((note) => {
            let fields = {};
            for (const [key, value] of Object.entries(srcFieldMapping)) {
                fields = {
                    ...fields,
                    [key]: lodash_1.default.get(note, `${value}`).toString(),
                };
            }
            return { fields };
        });
        return data;
    }
    async processNote(opts) {
        const { filteredNotes, apiKey, baseId, tableName, checkpoint, srcFieldMapping, } = opts;
        const headers = {
            Authorization: `Bearer ${apiKey}`,
            "Content-Type": "application/json",
        };
        const records = this.notesToSrcFieldMap(filteredNotes, srcFieldMapping);
        const chunks = lodash_1.default.chunk(records, 10);
        // rate limiter method
        const sendRequest = async () => {
            let total = 0;
            chunks.forEach(async (record) => {
                // @ts-ignore
                await limiter.removeTokens(1);
                const data = JSON.stringify({ records: record });
                try {
                    const result = await axios_1.default.post(`https://api.airtable.com/v0/${baseId}/${tableName}`, data, { headers: headers });
                    total = total + result.data.records.length;
                    if (total === filteredNotes.length) {
                        const timestamp = filteredNotes[filteredNotes.length - 1].created;
                        fs_extra_1.default.writeFileSync(checkpoint, timestamp.toString(), {
                            encoding: "utf8",
                        });
                    }
                }
                catch (error) {
                    this.L.error({
                        msg: "failed to export all the notes.",
                        payload: error,
                    });
                    throw new common_all_1.DendronError({ message: JSON.stringify(error) });
                }
            });
        };
        sendRequest();
    }
    verifyDir(dest) {
        const basePath = path_1.default.dirname(dest.fsPath);
        const checkpoint = path_1.default.join(basePath, "pods", ID, "airtable-pod.lastupdate", "checkpoint.txt");
        fs_extra_1.default.ensureDirSync(path_1.default.dirname(checkpoint));
        return checkpoint;
    }
    //filters the notes of src hierarchy given from all the notes
    filterNotes(notes, srcHierarchy) {
        return notes.filter((note) => note.fname.includes(srcHierarchy));
    }
    async plant(opts) {
        const { notes, config, dest } = opts;
        const { apiKey, baseId, tableName, srcFieldMapping, srcHierarchy } = config;
        const checkpoint = this.verifyDir(dest);
        let filteredNotes = srcHierarchy === "root" ? notes : this.filterNotes(notes, srcHierarchy);
        filteredNotes = lodash_1.default.orderBy(filteredNotes, ["created"], ["asc"]);
        if (fs_extra_1.default.existsSync(checkpoint)) {
            const lastUpdatedTimestamp = Number(fs_extra_1.default.readFileSync(checkpoint, { encoding: "utf8" }));
            filteredNotes = filteredNotes.filter((note) => note.created > lastUpdatedTimestamp);
        }
        if (filteredNotes.length > 0) {
            await this.processNote({
                filteredNotes,
                apiKey,
                baseId,
                tableName,
                srcFieldMapping,
                srcHierarchy,
                checkpoint,
            });
        }
        else {
            throw new common_all_1.DendronError({
                message: "No new Records to sync in selected hierarchy. Create new file and then try",
            });
        }
        return { notes };
    }
}
exports.AirtableExportPod = AirtableExportPod;
AirtableExportPod.id = ID;
AirtableExportPod.description = "export notes to airtable";
//# sourceMappingURL=AirtablePod.js.map