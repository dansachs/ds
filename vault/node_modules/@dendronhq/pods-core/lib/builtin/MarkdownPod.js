"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MarkdownExportPod = exports.MarkdownPublishPod = exports.MarkdownImportPod = void 0;
const common_all_1 = require("@dendronhq/common-all");
const common_server_1 = require("@dendronhq/common-server");
const engine_server_1 = require("@dendronhq/engine-server");
const fs_extra_1 = __importDefault(require("fs-extra"));
const klaw_1 = __importDefault(require("klaw"));
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const through2_1 = __importDefault(require("through2"));
const basev3_1 = require("../basev3");
const ID = "dendron.markdown";
const toMarkdownLink = (assetPath, opts) => {
    const name = (opts === null || opts === void 0 ? void 0 : opts.name) ? opts.name : path_1.default.parse(assetPath).name;
    return `- [${name}](${assetPath})`;
};
class MarkdownImportPod extends basev3_1.ImportPod {
    get config() {
        return super.config.concat([
            {
                key: "noAddUUID",
                description: "Don't add uuid to assets",
                type: "boolean",
            },
            {
                key: "indexName",
                description: "If you have an index file per directory, merge that file with the directory note",
                type: "string",
            },
        ]);
    }
    async _collectItems(root) {
        const items = []; // files, directories, symlinks, etc
        const mask = root.endsWith(path_1.default.sep) ? root.length : root.length + 1;
        const excludeFilter = through2_1.default.obj(function (item, _enc, _next) {
            // check if hidden file
            if (!lodash_1.default.some(item.path.split(path_1.default.sep), (ent) => ent.startsWith("."))) {
                this.push(item);
            }
            _next();
        });
        return new Promise((resolve, _reject) => {
            klaw_1.default(root)
                .pipe(excludeFilter)
                // eslint-disable-next-line prefer-arrow-callback
                .on("data", (item) => {
                const out = { ...item, entries: [] };
                if (item.path.endsWith(".md")) {
                    const { data, content } = common_server_1.readMD(item.path);
                    out.data = data;
                    out.body = content;
                }
                out.path = out.path.slice(mask);
                items.push(out);
            })
                .on("end", () => {
                this.L.info({ msg: "done collecting items" });
                resolve(items);
            });
        });
    }
    async _prepareItems(items) {
        const engineFileDict = {};
        const assetFileDict = {};
        // create map of files
        lodash_1.default.each(items, (v, _k) => {
            if (lodash_1.default.some([v.path.endsWith(".md"), v.stats.isDirectory()])) {
                engineFileDict[v.path] = v;
            }
            else {
                assetFileDict[v.path] = v;
            }
        });
        // add assets
        lodash_1.default.values(assetFileDict).forEach((ent) => {
            let dirname = path_1.default.dirname(ent.path);
            // root directories
            if (dirname === ".") {
                dirname = "";
            }
            engineFileDict[dirname].entries.push(ent);
        });
        return { engineFileDict, assetFileDict };
    }
    _files2HierarichalDict(opts) {
        const { files, src, vault, wsRoot, config } = opts;
        const out = {};
        lodash_1.default.forEach(files, (item) => {
            const fname = common_server_1.cleanFileName(item.path, {
                isDir: item.stats.isDirectory(),
            });
            const lvl = fname.split(".").length;
            if (!lodash_1.default.has(out, lvl)) {
                out[lvl] = [];
            }
            const isDir = item.stats.isDirectory();
            const stub = item.stats.isDirectory() && lodash_1.default.isEmpty(item.entries);
            const noteProps = common_all_1.NoteUtils.create({
                fname,
                stub,
                vault,
                custom: { isDir },
            });
            if (item === null || item === void 0 ? void 0 : item.body) {
                noteProps.body = item.body;
            }
            if (item === null || item === void 0 ? void 0 : item.data) {
                noteProps.data = item.data;
            }
            // deal with non-md files
            if (!lodash_1.default.isEmpty(item.entries)) {
                // move entries over
                // TODO: don't hardcode assets
                const assetDirName = "assets";
                const vpath = common_server_1.vault2Path({ vault, wsRoot });
                const assetDir = path_1.default.join(vpath, assetDirName);
                fs_extra_1.default.ensureDirSync(assetDir);
                const mdLinks = [];
                item.entries.map((_item) => {
                    const { ext, name } = path_1.default.parse(_item.path);
                    let assetBaseNew;
                    if (config.noAddUUID) {
                        assetBaseNew = `${common_server_1.cleanFileName(name)}${ext}`;
                    }
                    else {
                        const uuid = common_all_1.genUUID();
                        assetBaseNew = `${common_server_1.cleanFileName(name)}-${uuid}${ext}`;
                    }
                    const assetPathFull = path_1.default.join(assetDir, assetBaseNew);
                    const assetPathRel = path_1.default.join(assetDirName, assetBaseNew);
                    fs_extra_1.default.copyFileSync(path_1.default.join(src, _item.path), assetPathFull);
                    mdLinks.push(toMarkdownLink(`/${assetPathRel}`, { name: `${name}${ext}` }));
                });
                noteProps.body = `## Imported Assets\n${mdLinks.join("\n")}`;
            }
            out[lvl].push(noteProps);
        });
        return out;
    }
    hDict2Notes(hdict, config) {
        const noteDict = {};
        // TODO: currently don't handle stuff attached to root
        hdict[1]
            .filter((n) => !lodash_1.default.isEmpty(n.fname))
            .forEach((props) => {
            const n = common_all_1.NoteUtils.create({ ...props });
            noteDict[n.fname] = n;
        });
        let lvl = 2;
        let currRawNodes = hdict[lvl];
        while (!lodash_1.default.isEmpty(currRawNodes)) {
            currRawNodes.forEach((props) => {
                var _a;
                const parentPath = common_all_1.DNodeUtils.dirName(props.fname);
                if (noteDict[parentPath].custom.isDir &&
                    common_all_1.DNodeUtils.basename(props.fname.toLowerCase(), true) ===
                        ((_a = config.indexName) === null || _a === void 0 ? void 0 : _a.toLowerCase())) {
                    const n = noteDict[parentPath];
                    n.body = [props.body, "***", n.body].join("\n");
                    n.custom = props.custom;
                }
                else if (lodash_1.default.has(noteDict, parentPath)) {
                    const n = common_all_1.NoteUtils.create({ ...props });
                    common_all_1.DNodeUtils.addChild(noteDict[parentPath], n);
                    noteDict[n.fname] = n;
                }
                else {
                    throw Error("missing notes not supported yet");
                }
            });
            lvl += 1;
            currRawNodes = hdict[lvl];
        }
        return lodash_1.default.values(noteDict);
    }
    async plant(opts) {
        const ctx = "MarkdownPod";
        const { wsRoot, engine, src, vault, config } = opts;
        this.L.info({ ctx, wsRoot, src: src.fsPath, msg: "enter" });
        // get all items
        const items = await this._collectItems(src.fsPath);
        this.L.info({ ctx, wsRoot, numItems: lodash_1.default.size(items), msg: "collectItems" });
        const { engineFileDict } = await this._prepareItems(items);
        const hDict = this._files2HierarichalDict({
            files: lodash_1.default.values(engineFileDict),
            src: src.fsPath,
            vault,
            wsRoot,
            config,
        });
        const notes = this.hDict2Notes(hDict, config);
        const notesClean = await Promise.all(notes
            .filter((n) => !n.stub)
            .map(async (n) => {
            const cBody = await engine_server_1.MDUtilsV5.procRemarkFull({
                fname: n.fname,
                engine,
                dest: engine_server_1.DendronASTDest.MD_DENDRON,
                vault: n.vault,
            })
                .use(engine_server_1.RemarkUtils.convertLinksToDotNotation(n, []))
                .process(n.body);
            n.body = cBody.toString();
            if (config.frontmatter) {
                n.custom = lodash_1.default.merge(n.custom, config.frontmatter);
            }
            if (config.fnameAsId) {
                n.id = n.fname;
            }
            return n;
        }));
        await engine.bulkAddNotes({ notes: notesClean });
        this.L.info({
            ctx,
            wsRoot,
            src: src.fsPath,
            msg: `${lodash_1.default.size(notesClean)} notes imported`,
        });
        return notesClean;
    }
}
exports.MarkdownImportPod = MarkdownImportPod;
MarkdownImportPod.id = ID;
MarkdownImportPod.description = "import markdown";
class MarkdownPublishPod extends basev3_1.PublishPod {
    async plant(opts) {
        const { engine, note } = opts;
        const remark = engine_server_1.MDUtilsV4.procFull({
            dest: engine_server_1.DendronASTDest.MD_REGULAR,
            config: {
                ...engine.config,
                usePrettyRefs: false,
            },
            engine,
            fname: note.fname,
            vault: note.vault,
            shouldApplyPublishRules: false,
        }).use(engine_server_1.RemarkUtils.convertLinksFromDotNotation(note, []));
        const out = remark.processSync(note.body).toString();
        return lodash_1.default.trim(out);
    }
}
exports.MarkdownPublishPod = MarkdownPublishPod;
MarkdownPublishPod.id = ID;
MarkdownPublishPod.description = "publish markdown";
/**
 *
 */
class MarkdownExportPod extends basev3_1.ExportPod {
    async plant(opts) {
        const ctx = "MarkdownExportPod:plant";
        const { dest, notes, vaults, wsRoot } = opts;
        // verify dest exist
        const podDstPath = dest.fsPath;
        fs_extra_1.default.ensureDirSync(path_1.default.dirname(podDstPath));
        const mdPublishPod = new MarkdownPublishPod();
        this.L.info({ ctx, msg: "pre:iterate_notes" });
        await Promise.all(notes.map(async (note) => {
            const body = await mdPublishPod.plant({ ...opts, note });
            const hpath = dot2Slash(note.fname) + ".md";
            const vname = common_all_1.VaultUtils.getName(note.vault);
            let fpath = path_1.default.join(podDstPath, vname, hpath);
            // fpath = _.isEmpty(note.children)
            //   ? fpath + ".md"
            //   : path.join(fpath, "index.md");
            this.L.info({ ctx, fpath, msg: "pre:write" });
            await fs_extra_1.default.ensureDir(path_1.default.dirname(fpath));
            return fs_extra_1.default.writeFile(fpath, body);
        }));
        // Export Assets
        await Promise.all(vaults.map(async (vault) => {
            //TODO: Avoid hardcoding of assets directory, or else extract to global const
            const destPath = path_1.default.join(dest.fsPath, common_all_1.VaultUtils.getRelPath(vault), "assets");
            const srcPath = path_1.default.join(wsRoot, common_all_1.VaultUtils.getRelPath(vault), "assets");
            if (fs_extra_1.default.pathExistsSync(srcPath)) {
                await fs_extra_1.default.copy(srcPath, destPath);
            }
        }));
        return { notes };
    }
}
exports.MarkdownExportPod = MarkdownExportPod;
MarkdownExportPod.id = ID;
MarkdownExportPod.description = "export notes as markdown";
function dot2Slash(fname) {
    const hierarchy = fname.split(".");
    return path_1.default.join(...hierarchy);
}
//# sourceMappingURL=MarkdownPod.js.map