"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExportPod = exports.ImportPod = exports.PublishPod = void 0;
const common_all_1 = require("@dendronhq/common-all");
const common_server_1 = require("@dendronhq/common-server");
const lodash_1 = __importDefault(require("lodash"));
const vscode_uri_1 = require("vscode-uri");
class PublishPod {
    get config() {
        return [
            {
                key: "fname",
                description: "name of src file",
                type: "string",
            },
            {
                key: "vaultName",
                description: "name of src vault",
                type: "string",
            },
            {
                key: "dest",
                description: "where to export to",
                type: "string",
            },
        ];
    }
    async execute(opts) {
        const { config, engine } = opts;
        const { fname, vaultName } = config;
        if (lodash_1.default.isUndefined(vaultName)) {
            throw new common_all_1.DendronError({ message: "no vaultName" });
        }
        if (lodash_1.default.isUndefined(fname)) {
            throw new common_all_1.DendronError({ message: "no fname" });
        }
        const vault = common_all_1.VaultUtils.getVaultByNameOrThrow({
            vaults: engine.vaults,
            vname: vaultName,
        });
        const note = common_all_1.NoteUtils.getNoteByFnameV5({
            fname,
            notes: engine.notes,
            vault: vault,
            wsRoot: engine.wsRoot,
        });
        if (!note) {
            throw Error("no note found");
        }
        return this.plant({ ...opts, note });
    }
}
exports.PublishPod = PublishPod;
PublishPod.kind = "publish";
class ImportPod {
    constructor() {
        this.L = common_server_1.createLogger("ImportPod");
    }
    get config() {
        return [
            {
                key: "src",
                description: "Where to import from",
                type: "string",
                required: true,
            },
            {
                key: "vaultName",
                description: "name of vault to import into",
                type: "string",
                required: true,
            },
            {
                key: "concatenate",
                description: "whether to concatenate everything into one note",
                type: "boolean",
            },
            {
                key: "frontmatter",
                description: "frontmatter to add to each note",
                type: "object",
            },
            {
                key: "fnameAsId",
                description: "use the file name as the id",
                type: "boolean",
            },
            {
                key: "destName",
                description: "If concatenate is set, name of destination path",
                type: "string",
            },
        ];
    }
    validate(config) {
        const { src, vaultName, concatenate } = lodash_1.default.defaults(config, {
            concatenate: false,
        });
        const configJSON = JSON.stringify(config);
        if (lodash_1.default.isUndefined(src)) {
            throw new common_all_1.DendronError({
                message: `no src specified. config: ${configJSON}`,
            });
        }
        if (lodash_1.default.isUndefined(vaultName)) {
            throw new common_all_1.DendronError({ message: "no vaultName specified" });
        }
        if (concatenate && lodash_1.default.isUndefined(config === null || config === void 0 ? void 0 : config.destName)) {
            throw new common_all_1.DendronError({
                message: "destName must be specified if concatenate is enabled",
            });
        }
    }
    async execute(opts) {
        const { config, engine } = opts;
        this.validate(config);
        const { src, vaultName } = lodash_1.default.defaults(config, {
            concatenate: false,
        });
        // validate config
        const vault = common_all_1.VaultUtils.getVaultByNameOrThrow({
            vaults: engine.vaults,
            vname: vaultName,
        });
        const srcURL = vscode_uri_1.URI.file(common_server_1.resolvePath(src, engine.wsRoot));
        return await this.plant({ ...opts, src: srcURL, vault });
    }
}
exports.ImportPod = ImportPod;
ImportPod.kind = "import";
class ExportPod {
    constructor() {
        this.L = common_server_1.createLogger("ExportPod");
    }
    get config() {
        return [
            {
                key: "dest",
                description: "Where to export to",
                type: "string",
                required: true,
            },
            {
                key: "includeBody",
                description: "should body be included",
                default: true,
                type: "boolean",
            },
            {
                key: "includeStubs",
                description: "should stubs be included",
                type: "boolean",
            },
        ];
    }
    validate(config) {
        const { dest } = config;
        const configJSON = JSON.stringify(config);
        if (lodash_1.default.isUndefined(dest)) {
            throw new common_all_1.DendronError({
                message: `no dest specified. config: ${configJSON}`,
            });
        }
    }
    /**
     * Checks for some pre-sets
     * - if not `includeBody`, then fetch notes without body
     * - if not `includeStubs`, then ignore stub nodes
     */
    prepareNotesForExport({ config, notes, }) {
        const { includeBody } = lodash_1.default.defaults(config, { includeBody: true });
        if (!config.includeStubs) {
            notes = lodash_1.default.reject(notes, { stub: true });
        }
        if (!includeBody) {
            notes = notes.map((ent) => ({ ...ent, body: "" }));
        }
        return notes;
    }
    async execute(opts) {
        const { config, engine } = opts;
        this.validate(config);
        const { dest } = config;
        // validate config
        const destURL = vscode_uri_1.URI.file(common_server_1.resolvePath(dest, engine.wsRoot));
        // parse notes into NoteProps
        const notes = this.prepareNotesForExport({
            config,
            notes: lodash_1.default.values(engine.notes),
        });
        return await this.plant({ ...opts, dest: destURL, notes });
    }
}
exports.ExportPod = ExportPod;
ExportPod.kind = "export";
//# sourceMappingURL=basev3.js.map