"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileStorage = void 0;
const common_all_1 = require("@dendronhq/common-all");
const common_server_1 = require("@dendronhq/common-server");
const fs_extra_1 = __importDefault(require("fs-extra"));
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const utils_1 = require("../../markdown/remark/utils");
const hooks_1 = require("../../topics/hooks");
const utils_2 = require("../../utils");
const noteParser_1 = require("./noteParser");
const schemaParser_1 = require("./schemaParser");
// type NoteEntryV2 = {
//   mtime: number;
//   size: number;
//   hash: number;
// };
// type MetaEntryV2 = {
//   links: any[];
//   embeds: any[];
//   tags: any[];
//   headings: any[];
// };
class FileStorage {
    constructor(props) {
        const { vaults, wsRoot, config } = props.engine;
        const { logger } = props;
        this.wsRoot = wsRoot;
        this.configRoot = wsRoot;
        this.vaults = vaults;
        this.notes = {};
        this.schemas = {};
        this.notesCache = {
            version: 0,
            notes: {},
        };
        this.links = [];
        this.anchors = [];
        this.logger = logger;
        const ctx = "FileStorageV2";
        this.logger.info({ ctx, wsRoot, vaults, level: this.logger.level });
        this.config = config;
        this.engine = props.engine;
    }
    async init() {
        try {
            let error = null;
            const resp = await this.initSchema();
            if (!lodash_1.default.isNull(resp.error)) {
                error = common_all_1.DendronError.createPlainError({
                    message: "schema malformed",
                    severity: common_all_1.ERROR_SEVERITY.MINOR,
                    payload: { schema: resp.error },
                });
            }
            resp.data.map((ent) => {
                this.schemas[ent.root.id] = ent;
            });
            const _notes = await this.initNotes();
            _notes.map((ent) => {
                this.notes[ent.id] = ent;
            });
            const { notes, schemas } = this;
            return {
                data: {
                    notes,
                    schemas,
                    wsRoot: this.wsRoot,
                    config: this.config,
                    vaults: this.vaults,
                },
                error,
            };
        }
        catch (err) {
            this.logger.error(err);
            throw err;
        }
    }
    async deleteNote(id, opts) {
        const ctx = "deleteNote";
        if (id === "root") {
            throw new common_all_1.DendronError({
                message: "",
                status: common_all_1.ERROR_STATUS.CANT_DELETE_ROOT,
            });
        }
        const noteToDelete = this.notes[id];
        const ext = ".md";
        const vault = noteToDelete.vault;
        const vpath = common_server_1.vault2Path({ vault, wsRoot: this.wsRoot });
        const fpath = path_1.default.join(vpath, noteToDelete.fname + ext);
        let out = [];
        this.logger.info({ ctx, noteToDelete, opts });
        const noteAsLog = common_all_1.NoteUtils.toLogObj(noteToDelete);
        // remove from fs
        if (!(opts === null || opts === void 0 ? void 0 : opts.metaOnly)) {
            this.logger.info({ ctx, noteAsLog, msg: "removing from disk", fpath });
            fs_extra_1.default.unlinkSync(fpath);
        }
        // if have children, keep this node around as a stub
        if (!lodash_1.default.isEmpty(noteToDelete.children)) {
            this.logger.info({ ctx, noteAsLog, msg: "keep as stub" });
            noteToDelete.stub = true;
            this.updateNote(noteToDelete);
            out.push({ note: noteToDelete, status: "update" });
        }
        else {
            // no children, delete reference from parent
            this.logger.info({ ctx, noteAsLog, msg: "delete from parent" });
            if (!noteToDelete.parent) {
                throw common_all_1.DendronError.createFromStatus({
                    status: common_all_1.ERROR_STATUS.NO_PARENT_FOR_NOTE,
                });
            }
            // remove from parent
            let parentNote = this.notes[noteToDelete.parent];
            parentNote.children = lodash_1.default.reject(parentNote.children, (ent) => ent === noteToDelete.id);
            // delete from note dictionary
            delete this.notes[noteToDelete.id];
            // if parent note is not a stub, update it
            if (!parentNote.stub) {
                out.push({ note: parentNote, status: "update" });
            }
            out.push({ note: noteToDelete, status: "delete" });
            // check all stubs
            while (parentNote.stub && !(opts === null || opts === void 0 ? void 0 : opts.noDeleteParentStub)) {
                const newParent = parentNote.parent;
                const resp = await this.deleteNote(parentNote.id, {
                    metaOnly: true,
                    noDeleteParentStub: true,
                });
                if (newParent) {
                    parentNote = this.notes[newParent];
                }
                else {
                    common_all_1.assert(false, "illegal state in note delte");
                }
                out = out.concat(resp);
            }
        }
        return out;
    }
    async deleteSchema(id, opts) {
        const ctx = "deleteSchema";
        this.logger.info({ ctx, msg: "enter", id });
        if (id === "root") {
            throw common_all_1.DendronError.createFromStatus({
                status: common_all_1.ERROR_STATUS.CANT_DELETE_ROOT,
            });
        }
        const schemaToDelete = this.schemas[id];
        const ext = ".schema.yml";
        const vault = schemaToDelete.vault;
        const vpath = common_server_1.vault2Path({ vault, wsRoot: this.wsRoot });
        const fpath = path_1.default.join(vpath, schemaToDelete.fname + ext);
        if (!(opts === null || opts === void 0 ? void 0 : opts.metaOnly)) {
            fs_extra_1.default.unlinkSync(fpath);
        }
        delete this.schemas[id];
        return this.init();
    }
    async initSchema() {
        const ctx = "initSchema";
        this.logger.info({ ctx, msg: "enter" });
        const out = await Promise.all(this.vaults.map(async (vault) => {
            return this._initSchema(vault);
        }));
        const _out = lodash_1.default.reduce(out, (ent, acc) => {
            acc.data = acc.data.concat(ent.data);
            acc.errors = acc.errors.concat(ent.errors);
            return acc;
        }, { data: [], errors: [] });
        const { data, errors } = _out;
        return {
            data,
            error: lodash_1.default.isEmpty(errors)
                ? null
                : new common_all_1.DendronError({ message: "multiple errors", payload: errors }),
        };
    }
    async _initSchema(vault) {
        const ctx = "initSchema";
        this.logger.info({ ctx, msg: "enter" });
        const vpath = common_server_1.vault2Path({ vault, wsRoot: this.wsRoot });
        const schemaFiles = common_server_1.getAllFiles({
            root: vpath,
            include: ["*.schema.yml"],
        });
        this.logger.info({ ctx, schemaFiles });
        if (lodash_1.default.isEmpty(schemaFiles)) {
            throw common_all_1.DendronError.createFromStatus({
                status: common_all_1.ERROR_STATUS.NO_SCHEMA_FOUND,
            });
        }
        const { schemas, errors } = await new schemaParser_1.SchemaParser({
            store: this,
            logger: this.logger,
        }).parse(schemaFiles, vault);
        return {
            data: schemas,
            errors: lodash_1.default.isNull(errors) ? [] : errors,
        };
    }
    async initNotes() {
        const ctx = "initNotes";
        this.logger.info({ ctx, msg: "enter" });
        let notesWithLinks = [];
        const allNotesCache = {};
        const out = await Promise.all(this.vaults.map(async (vault) => {
            const { notes, cacheUpdates, cache } = await this._initNotes(vault);
            notesWithLinks = notesWithLinks.concat(lodash_1.default.filter(notes, (n) => !lodash_1.default.isEmpty(n.links)));
            allNotesCache[common_all_1.VaultUtils.getName(vault)] = {
                cache,
                cacheUpdates,
            };
            this.logger.info({
                ctx,
                vault,
                numEntries: lodash_1.default.size(notes),
                numCacheUpdates: lodash_1.default.size(cacheUpdates),
            });
            const newCache = {
                version: cache.version,
                notes: lodash_1.default.defaults(cacheUpdates, cache.notes),
            };
            const vpath = common_server_1.vault2Path({ vault, wsRoot: this.wsRoot });
            // OPT:make async and don't wait for return
            if (!this.engine.config.noCaching) {
                utils_2.writeNotesToCache(vpath, newCache);
            }
            return notes;
        }));
        const allNotes = lodash_1.default.flatten(out);
        this._addBacklinks({ notesWithLinks, allNotes, allNotesCache });
        return allNotes;
    }
    async _addBacklinks({ notesWithLinks, allNotes, }) {
        return lodash_1.default.map(notesWithLinks, async (noteFrom) => {
            try {
                return Promise.all(noteFrom.links.map(async (link) => {
                    var _a;
                    const fname = (_a = link.to) === null || _a === void 0 ? void 0 : _a.fname;
                    if (fname) {
                        const notes = common_all_1.NoteUtils.getNotesByFname({
                            fname,
                            notes: allNotes,
                        });
                        return notes.map((noteTo) => {
                            return common_all_1.NoteUtils.addBacklink({
                                from: noteFrom,
                                to: noteTo,
                                link,
                            });
                        });
                    }
                    return;
                }));
            }
            catch (err) {
                const error = common_all_1.error2PlainObject(err);
                this.logger.error({ error, noteFrom, message: "issue with backlinks" });
                return;
            }
        });
    }
    async _initNotes(vault) {
        const ctx = "initNotes";
        this.logger.info({ ctx, msg: "enter" });
        const wsRoot = this.wsRoot;
        const vpath = common_server_1.vault2Path({ vault, wsRoot });
        const noteFiles = common_server_1.getAllFiles({
            root: vpath,
            include: ["*.md"],
        });
        const cache = !this.engine.config.noCaching
            ? utils_2.readNotesFromCache(vpath)
            : { version: 0, notes: {} };
        const { notes, cacheUpdates } = await new noteParser_1.NoteParser({
            store: this,
            cache,
            logger: this.logger,
        }).parseFile(noteFiles, vault);
        await Promise.all(notes.map(async (n) => {
            if (n.stub) {
                return;
            }
            if (lodash_1.default.has(cacheUpdates, n.fname)) {
                const links = utils_1.LinkUtils.findLinks({
                    note: n,
                    engine: this.engine,
                });
                const anchors = await utils_1.AnchorUtils.findAnchors({
                    note: n,
                    wsRoot: wsRoot,
                }, {
                    engine: this.engine,
                    fname: n.fname,
                });
                cacheUpdates[n.fname].data.links = links;
                cacheUpdates[n.fname].data.anchors = anchors;
                n.links = links;
                n.anchors = anchors;
            }
            else {
                n.links = cache.notes[n.fname].data.links;
            }
            return;
        }));
        return { notes, cacheUpdates, cache };
    }
    async bulkAddNotes(opts) {
        this.logger.info({ ctx: "bulkAddNotes", msg: "enter" });
        await Promise.all(opts.notes.map((note) => {
            return common_server_1.note2File({
                note,
                vault: note.vault,
                wsRoot: this.wsRoot,
            });
        }));
        const notesChanged = opts.notes.map((n) => {
            return { note: n, status: "create" };
        });
        return {
            error: null,
            data: notesChanged,
        };
    }
    async renameNote(opts) {
        const ctx = "Store:renameNote";
        const { oldLoc, newLoc } = opts;
        const { wsRoot } = this;
        this.logger.info({ ctx, msg: "enter", opts });
        const oldVault = common_all_1.VaultUtils.getVaultByName({
            vaults: this.engine.vaults,
            vname: oldLoc.vaultName,
        });
        if (!oldVault) {
            throw new common_all_1.DendronError({ message: "vault not set for loation" });
        }
        const vpath = common_server_1.vault2Path({ wsRoot, vault: oldVault });
        const oldLocPath = path_1.default.join(vpath, oldLoc.fname + ".md");
        // read from disk since contents migh have changed
        const noteRaw = common_server_1.file2Note(oldLocPath, oldVault);
        const oldNote = common_all_1.NoteUtils.hydrate({
            noteRaw,
            noteHydrated: this.notes[noteRaw.id],
        });
        const notesToChange = await common_all_1.NoteUtils.getNotesWithLinkTo({
            note: oldNote,
            notes: this.notes,
        });
        this.logger.info({
            ctx,
            msg: "notesToChange:gather",
            notes: notesToChange.map((n) => common_all_1.NoteUtils.toLogObj(n)),
        });
        // update note body of all notes that have changed
        const notesChanged = await Promise.all(notesToChange.map(async (n) => {
            const vault = n.vault;
            const vaultPath = common_server_1.vault2Path({ vault, wsRoot });
            // read note in case its changed
            const _n = common_server_1.file2Note(path_1.default.join(vaultPath, n.fname + ".md"), vault);
            const foundLinks = utils_1.LinkUtils.findLinks({
                note: _n,
                engine: this.engine,
                filter: { loc: oldLoc },
            });
            const allLinks = lodash_1.default.orderBy(foundLinks, (link) => {
                return link.position.start.offset;
            }, "desc");
            const noteMod = lodash_1.default.reduce(allLinks, (note, link) => {
                const oldLink = utils_1.LinkUtils.dlink2DNoteLink(link);
                // current implementation adds alias for all notes
                // check if old note has alias thats different from its fname
                const alias = oldLink.from.alias &&
                    oldLink.from.alias.toLocaleLowerCase() !==
                        oldLink.from.fname.toLocaleLowerCase()
                    ? oldLink.from.alias
                    : undefined;
                // loc doesn't have header info
                const newBody = utils_1.LinkUtils.updateLink({
                    note,
                    oldLink,
                    newLink: {
                        ...oldLink,
                        from: {
                            ...newLoc,
                            anchorHeader: oldLink.from.anchorHeader,
                            alias,
                        },
                    },
                });
                _n.body = newBody;
                return _n;
            }, _n);
            // const resp = await MDUtilsV4.procTransform(
            //   { engine: this.engine, fname: n.fname, vault: n.vault },
            //   { from: oldLoc, to: newLoc }
            // ).process(_n.body);
            n.body = noteMod.body;
            return n;
        })).catch((err) => {
            this.logger.error({ err });
            throw new common_all_1.DendronError({ message: " error rename note", payload: err });
        });
        const newNote = {
            ...oldNote,
            fname: newLoc.fname,
            vault: common_all_1.VaultUtils.getVaultByName({
                vaults: this.vaults,
                vname: newLoc.vaultName,
            }),
            title: common_all_1.NoteUtils.isDefaultTitle(oldNote)
                ? common_all_1.NoteUtils.genTitle(newLoc.fname)
                : oldNote.title,
        };
        // NOTE: order matters. need to delete old note, otherwise can't write new note
        this.logger.info({
            ctx,
            msg: "deleteNote:meta:pre",
            note: common_all_1.NoteUtils.toLogObj(oldNote),
        });
        const changedFromDelete = await this.deleteNote(oldNote.id, {
            metaOnly: true,
        });
        this.logger.info({
            ctx,
            msg: "writeNewNote:pre",
            note: common_all_1.NoteUtils.toLogObj(newNote),
        });
        await this.writeNote(newNote, { newNode: true });
        this.logger.info({ ctx, msg: "updateAllNotes:pre" });
        // update all new notes
        await Promise.all(notesChanged.map(async (n) => {
            this.logger.info({
                ctx,
                msg: "writeNote:pre",
                note: common_all_1.NoteUtils.toLogObj(n),
            });
            return this.writeNote(n, { updateExisting: true });
        }));
        let out = notesChanged.map((note) => ({
            status: "update",
            note,
        }));
        // remove old note only when rename is success
        fs_extra_1.default.removeSync(oldLocPath);
        // create needs to be very last element added
        out = changedFromDelete
            .concat(out)
            .concat([{ status: "create", note: newNote }]);
        this.logger.info({ ctx, msg: "exit", opts, out });
        return out;
    }
    async updateNote(note, opts) {
        const ctx = "updateNote";
        const maybeNote = this.notes[note.id];
        if (maybeNote) {
            note = common_all_1.NoteUtils.hydrate({ noteRaw: note, noteHydrated: maybeNote });
        }
        if (opts === null || opts === void 0 ? void 0 : opts.newNode) {
            common_all_1.NoteUtils.addParent({
                note,
                notesList: lodash_1.default.values(this.notes),
                createStubs: true,
                wsRoot: this.wsRoot,
            });
        }
        this.logger.debug({ ctx, note: common_all_1.NoteUtils.toLogObj(note) });
        this.notes[note.id] = note;
        return note;
    }
    async updateSchema(schemaModule) {
        this.schemas[schemaModule.root.id] = schemaModule;
        // const vaultDir = this.vaults[0];
        // await schemaModuleProps2File(schemaModule, vaultDir, schemaModule.fname);
        // TODO: update notes
    }
    async _writeNewNote({ note, maybeNote, opts, }) {
        const ctx = "_writeNewNote";
        this.logger.info({
            ctx,
            msg: "enter",
            note: common_all_1.NoteUtils.toLogObj(note),
        });
        let changed = [];
        // if note exists, remove from parent and transplant children
        if (maybeNote) {
            // update changed
            const parentNote = this.notes[maybeNote.parent];
            // remove existing note from parent's children
            parentNote.children = lodash_1.default.reject(parentNote.children, (ent) => ent === maybeNote.id);
            // update parent's children
            this.notes[maybeNote.parent].children = parentNote.children;
            // move maybeNote's children to newly written note
            note.children = maybeNote.children;
            // delete maybeNote
            delete this.notes[maybeNote.id];
        }
        // after we have deleted parent, add the current note as a parent
        if (!(opts === null || opts === void 0 ? void 0 : opts.noAddParent)) {
            changed = common_all_1.NoteUtils.addParent({
                note,
                notesList: lodash_1.default.values(this.notes),
                createStubs: true,
                wsRoot: this.wsRoot,
            });
        }
        this.logger.info({
            ctx,
            msg: "exit",
            changed: changed.map((n) => common_all_1.NoteUtils.toLogObj(n)),
        });
        return changed;
    }
    async writeNote(note, opts) {
        const ctx = `FileStore:writeNote:${note.fname}`;
        let changed = [];
        let error = null;
        this.logger.info({
            ctx,
            msg: "enter",
            opts,
            note: common_all_1.NoteUtils.toLogObj(note),
        });
        const maybeNote = common_all_1.NoteUtils.getNoteByFnameV5({
            fname: note.fname,
            notes: this.notes,
            vault: note.vault,
            wsRoot: this.wsRoot,
        });
        this.logger.info({
            ctx,
            msg: "check:existing",
            maybeNoteId: lodash_1.default.pick(maybeNote || {}, ["id", "stub"]),
        });
        // don't count as delete if we're updating existing note
        let noDelete = false;
        if ((maybeNote === null || maybeNote === void 0 ? void 0 : maybeNote.stub) || (opts === null || opts === void 0 ? void 0 : opts.updateExisting)) {
            note = { ...maybeNote, ...note };
            noDelete = true;
        }
        else {
            changed = await this._writeNewNote({ note, maybeNote, opts });
        }
        // add schema if applicable
        const match = common_all_1.SchemaUtils.matchPath({
            notePath: note.fname,
            schemaModDict: this.schemas,
        });
        this.logger.info({
            ctx,
            msg: "pre:note2File",
        });
        const hooks = lodash_1.default.filter(this.engine.hooks.onCreate, (hook) => common_all_1.NoteUtils.match({ notePath: note.fname, pattern: hook.pattern }));
        const resp = await lodash_1.default.reduce(hooks, async (notePromise, hook) => {
            const { note } = await notePromise;
            const script = hooks_1.HookUtils.getHookScriptPath({
                wsRoot: this.wsRoot,
                basename: hook.id + ".js",
            });
            return await hooks_1.HookUtils.requireHook({
                note,
                fpath: script,
                wsRoot: this.wsRoot,
            });
        }, Promise.resolve({ note })).catch((err) => new common_all_1.DendronError({
            severity: common_all_1.ERROR_SEVERITY.MINOR,
            message: "error with hook",
            payload: common_all_1.stringifyError(err),
        }));
        if (resp instanceof common_all_1.DendronError) {
            error = resp;
            this.logger.error({ ctx, error: common_all_1.stringifyError(error) });
        }
        else {
            const valResp = common_all_1.NoteUtils.validate(resp.note);
            if (valResp instanceof common_all_1.DendronError) {
                error = valResp;
                this.logger.error({ ctx, error: common_all_1.stringifyError(error) });
            }
            else {
                note = resp.note;
                this.logger.info({ ctx, msg: "fin:RunHooks", payload: resp.payload });
            }
        }
        // order matters - only write file after parents are established @see(_writeNewNote)
        await common_server_1.note2File({
            note,
            vault: note.vault,
            wsRoot: this.wsRoot,
            opts: { writeHierarchy: opts === null || opts === void 0 ? void 0 : opts.writeHierarchy },
        });
        if (match) {
            this.logger.info({
                ctx,
                msg: "pre:addSchema",
            });
            const { schema, schemaModule } = match;
            common_all_1.NoteUtils.addSchema({ note, schema, schemaModule });
        }
        this.logger.info({
            ctx,
            msg: "pre:updateNotes",
        });
        await Promise.all([note].concat(changed).map((ent) => this.updateNote(ent)));
        const changedEntries = changed.map((ent) => ({
            note: ent,
            status: "update",
        }));
        changedEntries.push({ note, status: "create" });
        if (maybeNote && !noDelete) {
            changedEntries.push({ note: maybeNote, status: "delete" });
        }
        this.logger.info({
            ctx,
            msg: "exit",
        });
        return {
            error,
            data: changedEntries,
        };
    }
    async writeSchema(schemaModule) {
        this.schemas[schemaModule.root.id] = schemaModule;
        const vault = schemaModule.vault;
        const vpath = common_server_1.vault2Path({ vault, wsRoot: this.wsRoot });
        await common_server_1.schemaModuleProps2File(schemaModule, vpath, schemaModule.fname);
    }
}
exports.FileStorage = FileStorage;
//# sourceMappingURL=storev2.js.map