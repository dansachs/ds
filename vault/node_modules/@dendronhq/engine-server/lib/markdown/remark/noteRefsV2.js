"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.noteRefsV2 = exports.convertNoteRefASTV2 = void 0;
const common_all_1 = require("@dendronhq/common-all");
const common_server_1 = require("@dendronhq/common-server");
const lodash_1 = __importDefault(require("lodash"));
const mdast_builder_1 = require("mdast-builder");
const site_1 = require("../../topics/site");
const types_1 = require("../types");
const utils_1 = require("../utils");
const utilsv5_1 = require("../utilsv5");
const utils_2 = require("./utils");
const LINK_REGEX = /^\!\[\[(.+?)\]\]/;
const plugin = function (opts) {
    const procOptsV5 = utilsv5_1.MDUtilsV5.getProcOpts(this);
    attachParser(this);
    if (this.Compiler != null && !procOptsV5.parseOnly) {
        attachCompiler(this, opts);
    }
};
exports.noteRefsV2 = plugin;
function attachParser(proc) {
    function locator(value, fromIndex) {
        return value.indexOf("![[", fromIndex);
    }
    function inlineTokenizer(eat, value) {
        const match = LINK_REGEX.exec(value);
        if (match) {
            const linkMatch = match[1].trim();
            const link = utils_2.LinkUtils.parseNoteRef(linkMatch);
            // If the link is same file [[#header]], it's implicitly to the same file it's located in
            if (link.from.fname === "")
                link.from.fname = utils_1.MDUtilsV4.getDendronData(proc).fname;
            const { value } = utils_2.LinkUtils.parseLink(linkMatch);
            let refNote = {
                type: types_1.DendronASTTypes.REF_LINK_V2,
                data: {
                    link,
                },
                value,
            };
            return eat(match[0])(refNote);
        }
        return;
    }
    function inlineTokenizerV5(eat, value) {
        var _a;
        const procOpts = utilsv5_1.MDUtilsV5.getProcOpts(proc);
        const match = LINK_REGEX.exec(value);
        if (match) {
            const linkMatch = match[1].trim();
            if ((procOpts === null || procOpts === void 0 ? void 0 : procOpts.mode) === utilsv5_1.ProcMode.NO_DATA) {
                const link = utils_2.LinkUtils.parseNoteRefRaw(linkMatch);
                const { value } = utils_2.LinkUtils.parseLink(linkMatch);
                let refNote = {
                    type: types_1.DendronASTTypes.REF_LINK_V2,
                    data: {
                        link,
                    },
                    value,
                };
                return eat(match[0])(refNote);
            }
            else {
                const link = utils_2.LinkUtils.parseNoteRef(linkMatch);
                // If the link is same file [[#header]], it's implicitly to the same file it's located in
                if (((_a = link.from) === null || _a === void 0 ? void 0 : _a.fname) === "")
                    link.from.fname = utils_1.MDUtilsV4.getDendronData(proc).fname;
                const { value } = utils_2.LinkUtils.parseLink(linkMatch);
                let refNote = {
                    type: types_1.DendronASTTypes.REF_LINK_V2,
                    data: {
                        link,
                    },
                    value,
                };
                return eat(match[0])(refNote);
            }
        }
        return;
    }
    inlineTokenizer.locator = locator;
    inlineTokenizerV5.locator = locator;
    const Parser = proc.Parser;
    const inlineTokenizers = Parser.prototype.inlineTokenizers;
    const inlineMethods = Parser.prototype.inlineMethods;
    if (utilsv5_1.MDUtilsV5.isV5Active(proc)) {
        inlineTokenizers.refLinkV2 = inlineTokenizerV5;
        inlineMethods.splice(inlineMethods.indexOf("link"), 0, "refLinkV2");
    }
    else {
        inlineTokenizers.refLinkV2 = inlineTokenizer;
        inlineMethods.splice(inlineMethods.indexOf("link"), 0, "refLinkV2");
    }
    return Parser;
}
function attachCompiler(proc, opts) {
    const Compiler = proc.Compiler;
    const visitors = Compiler.prototype.visitors;
    const copts = lodash_1.default.defaults(opts || {}, {});
    const { dest } = utils_1.MDUtilsV4.getDendronData(proc);
    if (visitors) {
        visitors.refLinkV2 = function (node) {
            const ndata = node.data;
            if (dest === types_1.DendronASTDest.MD_DENDRON) {
                const { fname, alias } = ndata.link.from;
                const { anchorStart, anchorStartOffset, anchorEnd } = ndata.link.data;
                let link = alias ? `${alias}|${fname}` : fname;
                let suffix = "";
                let vaultPrefix = ndata.link.data.vaultName
                    ? `${common_all_1.CONSTANTS.DENDRON_DELIMETER}${ndata.link.data.vaultName}/`
                    : "";
                if (anchorStart) {
                    suffix += `#${anchorStart}`;
                }
                if (anchorStartOffset) {
                    suffix += `,${anchorStartOffset}`;
                }
                if (anchorEnd) {
                    suffix += `:#${anchorEnd}`;
                }
                return `![[${vaultPrefix}${link}${suffix}]]`;
            }
            const { error, data } = convertNoteRef({
                link: ndata.link,
                proc,
                compilerOpts: copts,
            });
            if (error) {
                return `ERROR converting ref: ${error.message}`;
            }
            return data;
        };
    }
}
const MAX_REF_LVL = 3;
/**
 * Look at links and do initial pass
 */
function convertNoteRef(opts) {
    let data;
    let errors = [];
    const { link, proc, compilerOpts } = opts;
    const { error, engine } = utils_1.MDUtilsV4.getEngineFromProc(proc);
    const refLvl = utils_1.MDUtilsV4.getNoteRefLvl(proc());
    let { dest, vault, config } = utils_1.MDUtilsV4.getDendronData(proc);
    if (link.data.vaultName) {
        vault = common_all_1.VaultUtils.getVaultByNameOrThrow({
            vaults: engine.vaults,
            vname: link.data.vaultName,
        });
    }
    if (!vault) {
        return {
            error: new common_all_1.DendronError({ message: "no vault specified" }),
            data: "",
        };
    }
    let { prettyRefs, wikiLinkOpts } = compilerOpts;
    if (refLvl >= MAX_REF_LVL) {
        return {
            error: new common_all_1.DendronError({ message: "too many nested note refs" }),
            data,
        };
    }
    let noteRefs = [];
    if (link.from.fname.endsWith("*")) {
        const resp = engine.queryNotesSync({ qs: link.from.fname, vault });
        const out = lodash_1.default.filter(resp.data, (ent) => common_all_1.DUtils.minimatch(ent.fname, link.from.fname));
        noteRefs = lodash_1.default.sortBy(out.map((ent) => common_all_1.NoteUtils.toNoteLoc(ent)), "fname");
    }
    else {
        noteRefs.push(link.from);
    }
    const out = noteRefs.map((ref) => {
        const fname = ref.fname;
        // TODO: find first unit with path
        const npath = common_all_1.DNodeUtils.getFullPath({
            wsRoot: engine.wsRoot,
            vault,
            basename: fname + ".md",
        });
        try {
            const note = common_server_1.file2Note(npath, vault);
            const body = note.body;
            const { error, data } = convertNoteRefHelper({
                body,
                note,
                link,
                refLvl: refLvl + 1,
                proc: utils_1.MDUtilsV4.setDendronData(proc(), {
                    overrides: { insertTitle: false },
                }),
                //proc,
                compilerOpts,
            });
            if (error) {
                errors.push(error);
            }
            if (prettyRefs) {
                let suffix = "";
                let href = (wikiLinkOpts === null || wikiLinkOpts === void 0 ? void 0 : wikiLinkOpts.useId) ? note.id : fname;
                if (dest === types_1.DendronASTDest.HTML) {
                    const maybeNote = common_all_1.NoteUtils.getNoteByFnameV5({
                        fname,
                        notes: engine.notes,
                        vault,
                        wsRoot: engine.wsRoot,
                    });
                    suffix = ".html";
                    if ((maybeNote === null || maybeNote === void 0 ? void 0 : maybeNote.custom.permalink) === "/") {
                        href = "";
                        suffix = "";
                    }
                }
                if (dest === types_1.DendronASTDest.MD_ENHANCED_PREVIEW) {
                    suffix = ".md";
                }
                const link = `"${(wikiLinkOpts === null || wikiLinkOpts === void 0 ? void 0 : wikiLinkOpts.prefix) || ""}${href}${suffix}"`;
                let title = getTitle({ config, note, loc: ref });
                return renderPretty({
                    content: data,
                    title,
                    link,
                });
            }
            else {
                return data;
            }
        }
        catch (err) {
            const msg = `error reading file, ${npath}`;
            errors.push(new common_all_1.DendronError({ message: msg }));
            return msg;
        }
    });
    return { error, data: out.join("\n") };
}
function convertNoteRefASTV2(opts) {
    let errors = [];
    const { link, proc, compilerOpts, procOpts } = opts;
    const { error, engine } = utils_1.MDUtilsV4.getEngineFromProc(proc);
    const refLvl = utils_1.MDUtilsV4.getNoteRefLvl(proc());
    let { dest, vault, config, shouldApplyPublishRules } = utils_1.MDUtilsV4.getDendronData(proc);
    if (link.data.vaultName) {
        vault = common_all_1.VaultUtils.getVaultByNameOrThrow({
            vaults: engine.vaults,
            vname: link.data.vaultName,
        });
    }
    if (!vault) {
        return {
            error: new common_all_1.DendronError({ message: "no vault specified" }),
            data: [],
        };
    }
    let { prettyRefs, wikiLinkOpts } = compilerOpts;
    if (!prettyRefs &&
        lodash_1.default.includes([types_1.DendronASTDest.HTML, types_1.DendronASTDest.MD_ENHANCED_PREVIEW], dest)) {
        prettyRefs = true;
    }
    if (refLvl >= MAX_REF_LVL) {
        return {
            error: new common_all_1.DendronError({ message: "too many nested note refs" }),
            data: [utils_1.MDUtilsV4.genMDMsg("too many nested note refs")],
        };
    }
    let noteRefs = [];
    if (link.from.fname.endsWith("*")) {
        const resp = engine.queryNotesSync({ qs: link.from.fname, vault });
        const out = lodash_1.default.filter(resp.data, (ent) => common_all_1.DUtils.minimatch(ent.fname, link.from.fname));
        noteRefs = lodash_1.default.sortBy(out.map((ent) => common_all_1.NoteUtils.toNoteLoc(ent)), "fname");
    }
    else {
        noteRefs.push(link.from);
    }
    const out = noteRefs.map((ref) => {
        const fname = ref.fname;
        // TODO: find first unit with path
        const npath = common_all_1.DNodeUtils.getFullPath({
            wsRoot: engine.wsRoot,
            vault,
            basename: fname + ".md",
        });
        try {
            const note = common_server_1.file2Note(npath, vault);
            if (shouldApplyPublishRules &&
                !site_1.SiteUtils.canPublish({
                    note,
                    config: config,
                    engine,
                })) {
                // TODO: in the future, add 403 pages
                return mdast_builder_1.paragraph();
            }
            const body = note.body;
            const { error, data } = convertNoteRefHelperAST({
                body,
                link,
                refLvl: refLvl + 1,
                proc,
                compilerOpts,
                procOpts,
                note,
            });
            if (error) {
                errors.push(error);
            }
            if (prettyRefs) {
                let suffix = "";
                let href = (wikiLinkOpts === null || wikiLinkOpts === void 0 ? void 0 : wikiLinkOpts.useId) ? note.id : fname;
                let title = getTitle({ config, note, loc: ref });
                if (dest === types_1.DendronASTDest.HTML) {
                    suffix = ".html";
                    if (note.custom.permalink === "/") {
                        href = "";
                        suffix = "";
                    }
                }
                if (dest === types_1.DendronASTDest.MD_ENHANCED_PREVIEW) {
                    suffix = ".md";
                    // NOTE: parsing doesn't work properly for first line, not sure why
                    // this HACK fixes it
                    data.children = [mdast_builder_1.brk].concat(data.children);
                }
                let isPublished = true;
                if (dest === types_1.DendronASTDest.HTML) {
                    isPublished = site_1.SiteUtils.isPublished({
                        note,
                        config: config,
                        engine,
                    });
                }
                const link = isPublished
                    ? `"${(wikiLinkOpts === null || wikiLinkOpts === void 0 ? void 0 : wikiLinkOpts.prefix) || ""}${href}${suffix}"`
                    : undefined;
                return renderPrettyAST({
                    content: data,
                    title,
                    link,
                });
            }
            else {
                return mdast_builder_1.paragraph(data);
            }
        }
        catch (err) {
            const msg = `error reading file, ${npath}`;
            errors.push(new common_all_1.DendronError({ message: msg }));
            throw Error(msg);
            // return msg;
        }
    });
    return { error, data: out };
}
exports.convertNoteRefASTV2 = convertNoteRefASTV2;
/** For any List in `nodes`, removes the children before or after the index of the following ListItem in `nodes`. */
function removeListItems({ nodes, remove, }) {
    for (let i = 0; i < nodes.length; i++) {
        const list = nodes[i];
        const listItem = nodes[i + 1];
        if (list.ancestor.type !== types_1.DendronASTTypes.LIST)
            continue;
        if (lodash_1.default.isUndefined(listItem)) {
            console.error("Found a list that has a list anchor in it, but no list items");
            continue; // Should never happen, but let's try to render at least the whole list if it does
        }
        if (remove === "after-index") {
            list.ancestor.children = list.ancestor.children.slice(undefined, listItem.index + 1);
        }
        else {
            // keep === after-index
            list.ancestor.children = list.ancestor.children.slice(listItem.index, undefined);
        }
    }
}
/** If there are nested lists with a single item in them, replaces the outer single-item lists with the first multi-item list. */
function removeSingleItemNestedLists(nodes) {
    let outermost;
    for (let i = 0; i < nodes.length; i++) {
        const list = nodes[i];
        if (list.ancestor.type !== types_1.DendronASTTypes.LIST)
            continue;
        // Find the outermost list
        if (lodash_1.default.isUndefined(outermost)) {
            outermost = list;
            // If the outermost list has multiple children, we have nothing to do
            if (outermost.ancestor.children.length > 1)
                return;
            continue;
        }
        else {
            // Found the nested list which will replace the outermost one
            outermost.ancestor.children = list.ancestor.children;
            // The nested list is the new outermost now
            outermost = list;
            // If we found a list with multiple children, stop because we want to keep it
            if (outermost.ancestor.children.length > 1)
                return;
        }
    }
}
function prepareNoteRefIndices({ anchorStart, anchorEnd, bodyAST, makeErrorData, }) {
    // TODO: can i just strip frontmatter when reading?
    let start = {
        type: "header",
        index: bodyAST.children[0].type === "yaml" ? 1 : 0,
    };
    let end = null;
    if (anchorStart) {
        start = findAnchor({
            nodes: bodyAST.children,
            match: anchorStart,
        });
        if (lodash_1.default.isNull(start)) {
            return {
                data: makeErrorData(anchorStart, "Start"),
                start: null,
                end: null,
                error: null,
            };
        }
    }
    if (anchorEnd) {
        end = findAnchor({
            nodes: bodyAST.children.slice(start.index),
            match: anchorEnd,
        });
        if (lodash_1.default.isNull(end)) {
            return {
                data: makeErrorData(anchorEnd, "End"),
                start: null,
                end: null,
                error: null,
            };
        }
        end.index += start.index;
    }
    else if (start.type === "block") {
        // If no end is specified and the start is a block anchor referencing a block, the end is implicitly the end of the referenced block.
        end = { type: "block", index: start.index };
    }
    else if (start.type === "list") {
        // If no end is specified and the start is a block anchor in a list, the end is the list element referenced by the start.
        end = { ...start };
    }
    // Handle anchors inside lists. Lists need to slice out sibling list items, and extract out nested lists.
    // We need to remove elements before the start or after the end.
    // We do end first and start second in case they refer to the same list, so that the indices don't shift.
    if (end && end.type === "list") {
        removeListItems({ nodes: end.ancestors, remove: "after-index" });
    }
    if (start && start.type === "list") {
        removeListItems({ nodes: start.ancestors, remove: "before-index" });
    }
    // If removing items left single-item nested lists at the start of the ancestors, we trim these out.
    if (end && end.type === "list") {
        removeSingleItemNestedLists(end.ancestors);
    }
    if (end && end.type === "header" && end.anchorType === "header") {
        // TODO: check if this does right thing with header
        end.index -= 1;
    }
    if (start && start.type === "list") {
        removeSingleItemNestedLists(start.ancestors);
    }
    return { start, end, data: null, error: null };
}
function convertNoteRefHelperAST(opts) {
    var _a;
    const { proc, refLvl, link, note } = opts;
    const noteRefProc = proc();
    // proc is the parser that was parsing the note the reference was in, so need to update fname to reflect that we are parsing the referred note
    utils_1.MDUtilsV4.setDendronData(noteRefProc, { fname: link.from.fname });
    const engine = utils_1.MDUtilsV4.getEngineFromProc(noteRefProc);
    utils_1.MDUtilsV4.setNoteRefLvl(noteRefProc, refLvl);
    const procOpts = utils_1.MDUtilsV4.getProcOpts(noteRefProc);
    let bodyAST;
    if ((_a = utils_1.MDUtilsV4.getProcOpts(proc).config) === null || _a === void 0 ? void 0 : _a.useNunjucks) {
        let contentsClean = utils_1.renderFromNoteProps({
            fname: note.fname,
            vault: note.vault,
            wsRoot: engine.engine.wsRoot,
            notes: engine.engine.notes,
        });
        bodyAST = noteRefProc.parse(contentsClean);
    }
    else {
        bodyAST = noteRefProc.parse(note.body);
    }
    const { anchorStart, anchorEnd, anchorStartOffset } = lodash_1.default.defaults(link.data, {
        anchorStartOffset: 0,
    });
    let { start, end, data, error } = prepareNoteRefIndices({
        anchorStart,
        anchorEnd,
        bodyAST,
        makeErrorData: (anchorName, anchorType) => {
            return utils_1.MDUtilsV4.genMDMsg(`${anchorType} anchor ${anchorName} not found`);
        },
    });
    if (data)
        return { data, error };
    // slice of interested range
    try {
        let out = mdast_builder_1.root(bodyAST.children.slice((start ? start.index : 0) + anchorStartOffset, end ? end.index + 1 : undefined));
        let tmpProc = utils_1.MDUtilsV4.procFull({ ...procOpts });
        tmpProc = utils_1.MDUtilsV4.setDendronData(tmpProc, { insideNoteRef: true });
        // let tmpProc = proc.data("procFull") as Processor;
        const { dest } = utils_1.MDUtilsV4.getDendronData(tmpProc);
        if (dest === types_1.DendronASTDest.HTML) {
            let out3 = tmpProc.runSync(out);
            return { error: null, data: out3 };
        }
        else {
            let out2 = tmpProc.stringify(out);
            out = tmpProc.parse(out2);
            return { error: null, data: out };
        }
    }
    catch (err) {
        console.log("ERROR WITH RE in AST");
        console.log(JSON.stringify(err));
        return {
            error: new common_all_1.DendronError({
                message: "error processing note ref",
                payload: err,
            }),
            data: utils_1.MDUtilsV4.genMDMsg("error processing ref"),
        };
    }
}
function convertNoteRefHelper(opts) {
    const { body, proc, refLvl, link } = opts;
    const noteRefProc = proc();
    // proc is the parser that was parsing the note the reference was in, so need to update fname to reflect that we are parsing the referred note
    utils_1.MDUtilsV4.setDendronData(noteRefProc, { fname: link.from.fname });
    utils_1.MDUtilsV4.setNoteRefLvl(noteRefProc, refLvl);
    const bodyAST = noteRefProc.parse(body);
    const { anchorStart, anchorEnd, anchorStartOffset } = link.data;
    let { start, end, data, error } = prepareNoteRefIndices({
        anchorStart,
        anchorEnd,
        bodyAST,
        makeErrorData: (anchorName, anchorType) => {
            return `${anchorType} anchor ${anchorName} not found`;
        },
    });
    if (data)
        return { data, error };
    // slice of interested range
    try {
        bodyAST.children = bodyAST.children.slice(start === null || start === void 0 ? void 0 : start.index, end === null || end === void 0 ? void 0 : end.index);
        let out = noteRefProc
            .processSync(noteRefProc.stringify(bodyAST))
            .toString();
        if (anchorStartOffset) {
            out = out.split("\n").slice(anchorStartOffset).join("\n");
        }
        return { error: null, data: out };
    }
    catch (err) {
        console.log("ERROR WITH REF");
        console.log(JSON.stringify(err));
        return {
            error: new common_all_1.DendronError({
                message: "error processing note ref",
                payload: err,
            }),
            data: "error processing ref",
        };
    }
}
/** Searches for anchors, then returns the index for the top-level ancestor.
 *
 * @param nodes The list of nodes to search through.
 * @param match The block anchor string, like "header-anchor" or "^block-anchor"
 * @returns The index of the top-level ancestor node in the list where the anchor was found, or -1 if not found.
 */
function findAnchor({ nodes, match, }) {
    if (common_all_1.isBlockAnchor(match)) {
        const anchorId = match.slice(1);
        return findBlockAnchor({ nodes, match: anchorId });
    }
    else {
        return findHeader({ nodes, match, slugger: common_all_1.getSlugger() });
    }
}
function findHeader({ nodes, match, slugger, }) {
    const foundIndex = utils_1.MDUtilsV4.findIndex(nodes, function (node, idx) {
        if (idx === 0 && match === "*") {
            return false;
        }
        return utils_1.MDUtilsV4.matchHeading(node, match, { slugger });
    });
    if (foundIndex < 0)
        return null;
    return { type: "header", index: foundIndex, anchorType: "header" };
}
/** Searches for block anchors, then returns the index for the top-level ancestor.
 *
 * @param nodes The list of nodes to search through.
 * @param match The block anchor string, like "header-anchor" or "^block-anchor"
 * @returns The index of the top-level ancestor node in the list where the anchor was found, or -1 if not found.
 */
function findBlockAnchor({ nodes, match, }) {
    // Find the anchor in the nodes
    let foundIndex;
    let foundAncestors = [];
    utils_1.MDUtilsV4.visitParentsIndices({
        nodes,
        test: types_1.DendronASTTypes.BLOCK_ANCHOR,
        visitor: ({ node, index, ancestors }) => {
            if (node.id === match) {
                // found anchor!
                foundIndex = ancestors.length > 0 ? ancestors[0].index : index;
                foundAncestors = ancestors;
                return false; // stop traversal
            }
            return true; // continue traversal
        },
    });
    if (lodash_1.default.isUndefined(foundIndex))
        return null;
    if (!lodash_1.default.isEmpty(foundAncestors)) {
        if (foundAncestors[0].ancestor.children.length === 1) {
            // If located by itself after a block, then the block anchor refers to the previous block
            return { type: "block", index: foundIndex - 1 };
        }
        if (foundAncestors[0].ancestor.type === types_1.DendronASTTypes.LIST) {
            // The block anchor is in a list, which will need special handling to slice the list elements
            return {
                type: "list",
                index: foundIndex,
                ancestors: foundAncestors,
                anchorType: "block",
            };
        }
    }
    // Otherwise, it's an anchor inside some regular block. The anchor refers to the block it's inside of.
    return { type: "block", index: foundIndex, anchorType: "block" };
}
function renderPretty(opts) {
    const { content, title, link } = opts;
    return `<div class="portal-container">
<div class="portal-head">
<div class="portal-backlink" >
<div class="portal-title">From <span class="portal-text-title">${title}</span></div>
<a href=${link} class="portal-arrow">Go to text <span class="right-arrow">→</span></a>
</div>
</div>
<div id="portal-parent-anchor" class="portal-parent" markdown="1">
<div class="portal-parent-fader-top"></div>
<div class="portal-parent-fader-bottom"></div>        

${lodash_1.default.trim(content)}

</div>    
</div>`;
}
function getTitle(opts) {
    const { config, note, loc } = opts;
    const { alias, fname } = loc;
    return config.useNoteTitleForLink ? note.title : alias || fname || "no title";
}
function renderPrettyAST(opts) {
    const { content, title, link } = opts;
    let linkLine = lodash_1.default.isUndefined(link)
        ? ""
        : `<a href=${link} class="portal-arrow">Go to text <span class="right-arrow">→</span></a>`;
    const top = `<div class="portal-container">
<div class="portal-head">
<div class="portal-backlink" >
<div class="portal-title">From <span class="portal-text-title">${title}</span></div>
${linkLine}
</div>
</div>
<div id="portal-parent-anchor" class="portal-parent" markdown="1">
<div class="portal-parent-fader-top"></div>
<div class="portal-parent-fader-bottom"></div>`;
    const bottom = `\n</div></div>`;
    return mdast_builder_1.paragraph([mdast_builder_1.html(top)].concat([content]).concat([mdast_builder_1.html(bottom)]));
}
//# sourceMappingURL=noteRefsV2.js.map