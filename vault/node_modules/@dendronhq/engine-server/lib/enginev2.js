"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createEngine = exports.DendronEngineV2 = void 0;
const common_all_1 = require("@dendronhq/common-all");
const common_server_1 = require("@dendronhq/common-server");
const lodash_1 = __importDefault(require("lodash"));
const config_1 = require("./config");
const storev2_1 = require("./drivers/file/storev2");
const fuseEngine_1 = require("./fuseEngine");
const markdown_1 = require("./markdown");
const utils_1 = require("./markdown/remark/utils");
const hooks_1 = require("./topics/hooks");
class DendronEngineV2 {
    constructor(props) {
        this.wsRoot = props.wsRoot;
        this.configRoot = props.wsRoot;
        this.logger = props.logger;
        this.props = props;
        this.fuseEngine = new fuseEngine_1.FuseEngine({});
        this.links = [];
        this.config = props.config;
        this._vaults = props.vaults;
        this.store = props.createStore(this);
        const hooks = lodash_1.default.get(props.config, "hooks", {
            onCreate: [],
        });
        this.hooks = hooks;
    }
    static create({ wsRoot, logger }) {
        const LOGGER = logger || common_server_1.createLogger();
        const cpath = config_1.DConfig.configPath(wsRoot);
        const config = common_server_1.readYAML(cpath);
        return new DendronEngineV2({
            wsRoot,
            vaults: config.vaults,
            forceNew: true,
            createStore: (engine) => new storev2_1.FileStorage({
                engine,
                logger: LOGGER,
            }),
            mode: "fuzzy",
            logger: LOGGER,
            config,
        });
    }
    static instance({ wsRoot }) {
        if (!DendronEngineV2._instance) {
            DendronEngineV2._instance = DendronEngineV2.create({ wsRoot });
        }
        return DendronEngineV2._instance;
    }
    get notes() {
        return this.store.notes;
    }
    get schemas() {
        return this.store.schemas;
    }
    get vaults() {
        return this._vaults;
    }
    set notes(notes) {
        this.store.notes = notes;
    }
    set vaults(vaults) {
        this._vaults = vaults;
        this.store.vaults = vaults;
    }
    /**
     * Does not throw error but returns it
     */
    async init() {
        try {
            const { data, error: storeError } = await this.store.init();
            if (lodash_1.default.isUndefined(data)) {
                return {
                    error: common_all_1.DendronError.createFromStatus({
                        status: common_all_1.ERROR_STATUS.UNKNOWN,
                        severity: common_all_1.ERROR_SEVERITY.FATAL,
                    }),
                };
            }
            const { notes, schemas } = data;
            this.updateIndex("note");
            this.updateIndex("schema");
            const hookErrors = [];
            this.hooks.onCreate = this.hooks.onCreate.filter((hook) => {
                const { valid, error } = hooks_1.HookUtils.validateHook({
                    hook,
                    wsRoot: this.wsRoot,
                });
                if (!valid && error) {
                    this.logger.error({ msg: "bad hook", hook, error });
                    hookErrors.push(error);
                }
                return valid;
            });
            const allErrors = (lodash_1.default.isNull(storeError) ? [] : [storeError]).concat(hookErrors);
            let error;
            switch (lodash_1.default.size(allErrors)) {
                case 0: {
                    error = null;
                    break;
                }
                case 1: {
                    error = new common_all_1.DendronError(allErrors[0]);
                    break;
                }
                default:
                    error = new common_all_1.DendronCompositeError(allErrors);
            }
            this.logger.info({ ctx: "init:ext", error, storeError, hookErrors });
            return {
                error,
                data: {
                    notes,
                    schemas,
                    wsRoot: this.wsRoot,
                    vaults: this.vaults,
                    config: this.config,
                },
            };
        }
        catch (error) {
            const { message, stack, status } = error;
            let payload = { message, stack };
            return {
                error: common_all_1.DendronError.createPlainError({
                    payload,
                    message,
                    status,
                    severity: common_all_1.ERROR_SEVERITY.FATAL,
                }),
            };
        }
    }
    async bulkAddNotes(opts) {
        const changed = await this.store.bulkAddNotes(opts);
        await this.refreshNotesV2(changed.data);
        return changed;
    }
    async deleteNote(id, opts) {
        try {
            const note = this.notes[id];
            const changed = await this.store.deleteNote(id, opts);
            const noteChangeEntry = lodash_1.default.find(changed, (ent) => ent.note.id === id);
            if (noteChangeEntry.status === "delete") {
                await this.fuseEngine.removeNoteFromIndex(note);
            }
            return {
                data: changed,
                error: null,
            };
        }
        catch (err) {
            return {
                data: [],
                error: err,
            };
        }
    }
    async deleteSchema(id, opts) {
        try {
            const data = (await this.store.deleteSchema(id, opts));
            // deleted schema might affect notes
            await this.updateIndex("note");
            await this.updateIndex("schema");
            return data;
            // FIXM:E not performant
            // const smod = this.schemas[id];
            // await this.fuseEngine.removeSchemaFromIndex(smod);
            // return {
            //   data: undefined,
            //   error: null,
            // };
        }
        catch (err) {
            return {
                error: err,
            };
        }
    }
    async getNoteByPath({ npath, createIfNew, vault, overrides, }) {
        const ctx = "getNoteByPath";
        this.logger.debug({ ctx, npath, createIfNew, msg: "enter" });
        const maybeNote = common_all_1.NoteUtils.getNoteByFnameV5({
            fname: npath,
            notes: this.notes,
            vault,
            wsRoot: this.wsRoot,
        });
        this.logger.debug({ ctx, maybeNote, msg: "post-query" });
        let noteNew = maybeNote;
        let changed = [];
        let error = null;
        let updateExisting = false;
        if ((!maybeNote || maybeNote.stub) && createIfNew) {
            this.logger.debug({ ctx, maybeNote, msg: "create-new" });
            if (maybeNote === null || maybeNote === void 0 ? void 0 : maybeNote.stub) {
                noteNew = maybeNote;
                delete noteNew.stub;
                updateExisting = true;
            }
            else {
                noteNew = common_all_1.NoteUtils.createWithSchema({
                    noteOpts: { fname: npath, vault },
                    engine: this,
                });
            }
            noteNew = lodash_1.default.merge(noteNew, overrides || {});
            changed = (await this.writeNote(noteNew, { updateExisting })).data;
        }
        if (!createIfNew && !maybeNote) {
            error = new common_all_1.DendronError({ message: "no_note_found" });
        }
        await this.refreshNotesV2(changed);
        return {
            data: { note: noteNew, changed },
            error,
        };
    }
    async getConfig() {
        const cpath = config_1.DConfig.configPath(this.configRoot);
        const config = common_server_1.readYAML(cpath);
        return {
            error: null,
            data: config,
        };
    }
    async getSchema(id) {
        const ctx = "getSchema";
        const data = this.schemas[id];
        this.logger.info({ ctx, msg: "exit" });
        return {
            data,
            error: null,
        };
    }
    async info() {
        return {
            data: {
                version: common_server_1.NodeJSUtils.getVersionFromPkg(),
            },
            error: null,
        };
    }
    queryNotesSync({ qs, }) {
        const items = this.fuseEngine.queryNote({ qs });
        return {
            error: null,
            data: items.map((ent) => this.notes[ent.id]),
        };
    }
    async querySchema(queryString) {
        const ctx = "querySchema";
        let items = [];
        const results = await this.fuseEngine.querySchema({ qs: queryString });
        items = results.map((ent) => this.schemas[ent.id]);
        // if (queryString === "") {
        //   items = [this.schemas.root];
        // } else if (queryString === "*") {
        //   items = _.values(this.schemas);
        // } else {
        //   const results = this.schemaIndex.search(queryString);
        //   items = _.map(results, (resp) => this.schemas[resp.item.id]);
        // }
        this.logger.info({ ctx, msg: "exit" });
        return {
            error: null,
            data: items,
        };
    }
    async queryNotes(opts) {
        const ctx = "Engine:queryNotes";
        const { qs, vault, createIfNew } = opts;
        let items = await this.fuseEngine.queryNote({ qs });
        let item = this.notes[items[0].id];
        if (createIfNew) {
            let noteNew;
            if ((item === null || item === void 0 ? void 0 : item.fname) === qs && (item === null || item === void 0 ? void 0 : item.stub)) {
                noteNew = item;
                noteNew.stub = false;
            }
            else {
                if (lodash_1.default.isUndefined(vault)) {
                    return {
                        error: new common_all_1.DendronError({ message: "no vault specified" }),
                        data: null,
                    };
                }
                noteNew = common_all_1.NoteUtils.create({ fname: qs, vault });
            }
            const changed = await this.writeNote(noteNew, { newNode: true });
            await this.refreshNotesV2(changed.data);
        }
        this.logger.info({ ctx, msg: "exit" });
        let notes = items.map((ent) => this.notes[ent.id]);
        if (!lodash_1.default.isUndefined(vault)) {
            notes = notes.filter((ent) => common_all_1.VaultUtils.isEqual(vault, ent.vault, this.wsRoot));
        }
        return {
            error: null,
            data: notes,
        };
    }
    async renderNote({ id }) {
        const note = this.notes[id];
        if (!note) {
            return {
                error: common_all_1.DendronError.createFromStatus({
                    status: common_all_1.ERROR_STATUS.INVALID_STATE,
                    message: `${id} does not exist`,
                }),
                data: undefined,
            };
        }
        const proc = markdown_1.MDUtilsV4.procHTML({
            engine: this,
            vault: note.vault,
            fname: note.fname,
            config: this.config,
            noteIndex: {},
            useLinks: false,
        });
        const payload = await proc.process(common_all_1.NoteUtils.serialize(note));
        return {
            error: null,
            data: payload.toString(),
        };
    }
    async sync() {
        throw Error("sync not implemented");
        return {};
    }
    async refreshNotesV2(notes) {
        await Promise.all(notes.map(async (ent) => {
            const { id } = ent.note;
            //const uri = NoteUtils.getURI({ note: ent.note, wsRoot: this.wsRoot });
            if (ent.status === "delete") {
                delete this.notes[id];
                // this.history &&
                //   this.history.add({ source: "engine", action: "delete", uri });
            }
            else {
                if (ent.status === "create") {
                    // this.history &&
                    //   this.history.add({ source: "engine", action: "create", uri });
                }
                const links = markdown_1.LinkUtils.findLinks({ note: ent.note, engine: this });
                const anchors = await utils_1.AnchorUtils.findAnchors({
                    note: ent.note,
                    wsRoot: this.wsRoot,
                }, {
                    engine: this,
                    fname: ent.note.fname,
                });
                ent.note.links = links;
                ent.note.anchors = anchors;
                this.notes[id] = ent.note;
            }
        }));
        this.fuseEngine.updateNotesIndex(this.notes);
    }
    async renameNote(opts) {
        try {
            const resp = await this.store.renameNote(opts);
            await this.refreshNotesV2(resp);
            return {
                error: null,
                data: resp,
            };
        }
        catch (err) {
            return {
                error: new common_all_1.DendronError({ message: "rename error", payload: err }),
            };
        }
    }
    async updateNote(note, opts) {
        const out = this.store.updateNote(note, opts);
        await this.updateIndex("note");
        return out;
    }
    async updateIndex(mode) {
        if (mode === "schema") {
            this.fuseEngine.updateSchemaIndex(this.schemas);
        }
        else {
            this.fuseEngine.updateNotesIndex(this.notes);
        }
    }
    async updateSchema(schemaModule) {
        const out = await this.store.updateSchema(schemaModule);
        await this.updateIndex("schema");
        return out;
    }
    async writeConfig(opts) {
        const { configRoot } = this;
        const cpath = config_1.DConfig.configPath(configRoot);
        common_server_1.writeYAML(cpath, opts.config);
        return {
            error: null,
        };
    }
    async writeNote(note, opts) {
        const out = await this.store.writeNote(note, opts);
        await this.refreshNotesV2(out.data);
        return out;
    }
    async writeSchema(schema) {
        return this.store.writeSchema(schema);
    }
}
exports.DendronEngineV2 = DendronEngineV2;
const createEngine = ({ wsRoot }) => {
    const engine = DendronEngineV2.create({ wsRoot });
    return engine;
};
exports.createEngine = createEngine;
//# sourceMappingURL=enginev2.js.map